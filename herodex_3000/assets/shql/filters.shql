-- ============================================
-- Filters & Predicates
-- ============================================

-- _filter_lambdas stays global (set by Dart FilterCompiler via setVariable)
_filter_lambdas := {};

Filters := OBJECT{
    -- Named filters (persisted). Each filter is OBJECT{name, predicate}.
    -- Use RESET_PREDICATES() to restore defaults.
    -- "Giants" and "Dwarves" demonstrate computed predicates using Stats namespace.
    DEFAULT_FILTERS: [
        OBJECT{name: "Heroes", predicate: "biography.alignment <= good"},
        OBJECT{name: "Villains", predicate: "biography.alignment > good"},
        OBJECT{name: "Giants", predicate: "appearance.height.m > Stats.height_avg + 2 * Stats.height_stdev"},
        OBJECT{name: "Dwarves", predicate: "appearance.height.m < Stats.height_avg - 2 * Stats.height_stdev"},
        OBJECT{name: "Red Heads", predicate: 'appearance.hair_colour ~ "red"'},
        OBJECT{name: "Obese", predicate: "appearance.weight.kg / POW(appearance.height.m, 2) >= 30"},
        OBJECT{name: "Strong Villains", predicate: "biography.alignment > reasonable AND powerstats.strength >= powerstats.intelligence*1.1"},
        OBJECT{name: "Dumb Villains", predicate: "biography.alignment >= bad AND powerstats.intelligence <= 50"},
        OBJECT{name: "Non-Males", predicate: "appearance.gender <> male"},
        OBJECT{name: "Troglodytes", predicate: 'work.base ~ "cave"'}
    ],
    filters: LOAD_STATE('filters', DEFAULT_FILTERS),
    filter_counts: [],
    filtered_heroes: [],
    active_filter_index: -1,
    displayed_heroes: [],
    current_query: '',
    is_compiling: FALSE,
    is_filtering: FALSE,

    -- Setter methods (assign member + notify Observer)
    SET_FILTERS: (value) => BEGIN
        filters := value;
        PUBLISH('Filters.filters');
    END,

    SET_FILTER_COUNTS: (value) => BEGIN
        filter_counts := value;
        PUBLISH('Filters.filter_counts');
    END,

    SET_DISPLAYED_HEROES: (value) => BEGIN
        displayed_heroes := value;
        PUBLISH('Filters.displayed_heroes');
    END,

    SET_ACTIVE_FILTER_INDEX: (value) => BEGIN
        active_filter_index := value;
        PUBLISH('Filters.active_filter_index');
    END,

    SET_CURRENT_QUERY: (value) => BEGIN
        current_query := value;
        PUBLISH('Filters.current_query');
    END,

    SET_IS_COMPILING: (value) => BEGIN
        is_compiling := value;
        PUBLISH('Filters.is_compiling');
    END,

    SET_IS_FILTERING: (value) => BEGIN
        is_filtering := value;
        PUBLISH('Filters.is_filtering');
    END,

    -- Remove a hero from displayed_heroes by ID.
    REMOVE_FROM_DISPLAYED: (__id) => BEGIN
        __new := [];
        IF LENGTH(displayed_heroes) > 0 THEN
            FOR __i := 0 TO LENGTH(displayed_heroes) - 1 DO
                IF displayed_heroes[__i].ID <> __id THEN
                    __new := __new + [displayed_heroes[__i]];
        SET_DISPLAYED_HEROES(__new);
    END,

    -- Apply a predicate to a hero list, returning a map of matching heroes keyed by ID.
    APPLY_PREDICATE: (__hero_list, __pred, __predText) => BEGIN
        __result := {};
        IF LENGTH(__hero_list) > 0 THEN
            FOR __j := 0 TO LENGTH(__hero_list) - 1 DO BEGIN
                __hero := __hero_list[__j];
                __match := _EVAL_PREDICATE(__hero, __pred, __predText);
                IF __match THEN
                    __result[__hero.ID] := __hero;
            END;
        RETURN __result;
    END,

    -- Rebuild all filter result maps from scratch.
    REBUILD_ALL_FILTERS: () => BEGIN
        __hero_list := MAP_VALUES(Heroes.heroes);
        filtered_heroes := [];
        filter_counts := [];
        DEBUG_LOG('[REBUILD] start: ' + STRING(LENGTH(filters)) + ' filters, ' + STRING(LENGTH(__hero_list)) + ' heroes');
        FOR __i := 0 TO LENGTH(filters) - 1 DO BEGIN
            __predText := filters[__i].PREDICATE;
            __fname := filters[__i].NAME;
            __pred := IF __predText = '' OR __predText = null THEN null ELSE _filter_lambdas[__fname];
            DEBUG_LOG('[REBUILD]   [' + STRING(__i) + '] name="' + __fname + '" pred=' + IF __pred <> null THEN 'lambda' ELSE 'NULL' + ' predText="' + __predText + '"');
            __result := APPLY_PREDICATE(__hero_list, __pred, __predText);
            filtered_heroes := filtered_heroes + [__result];
            filter_counts := filter_counts + [LENGTH(__result)];
            DEBUG_LOG('[REBUILD]   [' + STRING(__i) + '] name="' + __fname + '" count=' + STRING(LENGTH(__result)));
        END;
        SET_FILTER_COUNTS(filter_counts);
        UPDATE_DISPLAYED_HEROES();
        DEBUG_LOG('[REBUILD] done: counts=' + STRING(filter_counts));
    END,

    -- Update displayed_heroes from the active filter or full hero map.
    UPDATE_DISPLAYED_HEROES: () => BEGIN
        IF active_filter_index < 0 OR active_filter_index >= LENGTH(filtered_heroes) THEN
            SET_DISPLAYED_HEROES(MAP_VALUES(Heroes.heroes))
        ELSE
            SET_DISPLAYED_HEROES(MAP_VALUES(filtered_heroes[active_filter_index]));
    END,

    -- Filter heroes by a compiled predicate and update displayed_heroes.
    FILTER_DISPLAYED: (__pred, __predText) => BEGIN
        __matched := APPLY_PREDICATE(MAP_VALUES(Heroes.heroes), __pred, __predText);
        SET_DISPLAYED_HEROES(MAP_VALUES(__matched));
    END,

    -- Persist filters to cloud and notify observers.
    __PERSIST_FILTERS: () => BEGIN
        Cloud.SAVE_PREF('filters', filters);
        SET_FILTERS(filters);
    END,

    -- Apply a filter by index (-1 = All, 0+ = index into filter arrays).
    APPLY_FILTER: (index) => BEGIN
        SET_ACTIVE_FILTER_INDEX(index);
        SET_CURRENT_QUERY('');
        UPDATE_DISPLAYED_HEROES();
    END,

    -- Save or update a named filter.
    SAVE_FILTER: (name, predicate) => BEGIN
        new_filters := [];
        found := FALSE;
        FOR i := 0 TO LENGTH(filters) - 1 DO BEGIN
            IF filters[i].name = name THEN BEGIN
                new_filters := new_filters + [OBJECT{name: name, predicate: predicate}];
                found := TRUE;
            END ELSE
                new_filters := new_filters + [filters[i]];
        END;
        filters := IF found THEN new_filters ELSE filters + [OBJECT{name: name, predicate: predicate}];
        __PERSIST_FILTERS();
    END,

    -- Delete any filter by index.
    DELETE_FILTER: (index) => BEGIN
        IF index < 0 OR index >= LENGTH(filters) THEN RETURN;
        new_filters := [];
        FOR i := 0 TO LENGTH(filters) - 1 DO
            IF i <> index THEN
                new_filters := new_filters + [filters[i]];
        filters := new_filters;
        __PERSIST_FILTERS();
        IF active_filter_index >= LENGTH(filters) OR active_filter_index = index THEN
            APPLY_FILTER(-1);
    END,

    -- Reset to the default filters.
    RESET_PREDICATES: () => BEGIN
        filters := DEFAULT_FILTERS;
        __PERSIST_FILTERS();
        APPLY_FILTER(-1);
    END,

    -- Add a new empty filter and select it for editing
    ADD_FILTER: () => BEGIN
        SAVE_FILTER('New Filter', '');
        APPLY_FILTER(LENGTH(filters) - 1);
    END,

    -- Rename a filter by index
    RENAME_FILTER: (index, new_name) => BEGIN
        IF index < 0 OR index >= LENGTH(filters) THEN RETURN;
        old := filters[index];
        new_filters := [];
        FOR i := 0 TO LENGTH(filters) - 1 DO
            IF i = index THEN
                new_filters := new_filters + [OBJECT{name: new_name, predicate: old.predicate}]
            ELSE
                new_filters := new_filters + [filters[i]];
        filters := new_filters;
        __PERSIST_FILTERS();
    END,

    -- Apply an ad-hoc query without saving it as a named filter
    APPLY_QUERY: (expression) => BEGIN
        SET_CURRENT_QUERY(expression);
        SET_ACTIVE_FILTER_INDEX(-1);
    END,

    -- Handle query change: compile, filter, manage IS_FILTERING state.
    -- _COMPILE_QUERY is a Dart callback that compiles a query string to a lambda.
    ON_QUERY_CHANGED: () => BEGIN
        __query := TRIM(current_query);
        IF __query = '' THEN BEGIN
            UPDATE_DISPLAYED_HEROES();
            RETURN;
        END;
        SET_IS_FILTERING(TRUE);
        __lambda := _COMPILE_QUERY(__query);
        IF __lambda <> null THEN
            FILTER_DISPLAYED(__lambda, __query)
        ELSE
            UPDATE_DISPLAYED_HEROES();
        SET_IS_FILTERING(FALSE);
    END,

    -- Return a display state object for card rebuilding: {heroes, empty_card}.
    -- empty_card is a widget tree shown when displayed_heroes is empty.
    GET_DISPLAY_STATE: () => BEGIN
        IF LENGTH(displayed_heroes) = 0 THEN BEGIN
            __msg := IF LENGTH(current_query) > 0 THEN
                'No heroes match "' + current_query + '"'
            ELSE
                'No heroes match this filter';
            RETURN OBJECT{heroes: [], empty_card: {
                "type": "Center",
                "child": {"type": "Text", "props": {"data": __msg, "style": {"fontSize": 16, "color": "0xFF757575"}}}
            }};
        END;
        RETURN OBJECT{heroes: displayed_heroes, empty_card: null};
    END,

    -- Return all state needed by the filter editor widget in one call.
    GET_EDITOR_STATE: () => OBJECT{
        filters: filters,
        filter_counts: filter_counts,
        active_filter_index: active_filter_index,
        current_query: current_query,
        is_compiling: is_compiling,
        is_filtering: is_filtering,
        total_heroes: LENGTH(Heroes.heroes)
    },

    -- Full rebuild: compile predicates (Dart callback), rebuild filter maps, update display.
    FULL_REBUILD: () => BEGIN
        SET_IS_COMPILING(TRUE);
        _COMPILE_FILTERS;
        REBUILD_ALL_FILTERS();
        SET_IS_COMPILING(FALSE);
    END,

    GET_FILTER_COUNT: (index) => IF index < 0 OR index >= LENGTH(filter_counts) THEN 0 ELSE filter_counts[index],

    -- Generate filter list items for home screen
    GENERATE_FILTER_COUNTER_CARDS: () => BEGIN
        result := [];
        __icons := ['shield', 'dangerous'];
        __colors := ['0xFF2196F3', '0xFFF44336'];

        FOR i := 0 TO LENGTH(filters) - 1 DO BEGIN
            count := IF i < LENGTH(filter_counts) THEN filter_counts[i] ELSE 0;
            icon := IF i < LENGTH(__icons) THEN __icons[i] ELSE 'label';
            color := IF i < LENGTH(__colors) THEN __colors[i] ELSE '0xFF9E9E9E';
            name := filters[i].name;

            item := {
                "type": "Card",
                "props": {
                    "onTap": "shql: Filters.APPLY_FILTER(" + STRING(i) + "); Nav.GO_TO('heroes')",
                    "child": {
                        "type": "Padding",
                        "props": {
                            "padding": 8,
                            "child": {
                                "type": "Row",
                                "props": {
                                    "children": [
                                        {"type": "Icon", "props": {"icon": icon, "color": color, "size": 20}},
                                        {"type": "SizedBox", "props": {"width": 12}},
                                        {"type": "Expanded", "child": {"type": "Text", "props": {"data": name}}},
                                        {"type": "Text", "props": {"data": STRING(count), "style": {"fontWeight": "bold", "fontSize": 16}}}
                                    ]
                                }
                            }
                        }
                    }
                }
            };
            result := result + [item];
        END;
        RETURN result;
    END
};
