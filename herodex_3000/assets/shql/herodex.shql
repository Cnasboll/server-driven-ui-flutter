-- ============================================
-- HeroDex 3000 - SHQL™ Functions
-- ============================================

-- Hero Model Accessors, Value Type Helpers, _detail_fields, and _summary_fields
-- are auto-generated by HeroSchema from the Field tree (loaded before this file).

-- ============================================
-- Navigation
-- ============================================
_tab_routes := ['home', 'online', 'heroes', 'settings'];
_navigation_stack := LOAD_STATE('navigation_stack', ['home']);

TAB_NAV(current, idx) := IF idx <> current THEN GO_TO(_tab_routes[idx]);

PUSH_ROUTE(route) := BEGIN
    IF LENGTH(_navigation_stack) = 0 THEN
        _navigation_stack := [route]
    ELSE BEGIN
        current_route := _navigation_stack[LENGTH(_navigation_stack) - 1];
        IF current_route <> route THEN BEGIN
            IF route IN _navigation_stack THEN
                _navigation_stack := SLICE(_navigation_stack, 0, INDEX_OF(_navigation_stack, route))
            ELSE
                _navigation_stack := _navigation_stack + [route];
        END;
    END;
    SET('_navigation_stack', _navigation_stack);
    SAVE_STATE('navigation_stack', _navigation_stack);
    RETURN _navigation_stack;
END;

POP_ROUTE() := BEGIN
    IF LENGTH(_navigation_stack) > 1 THEN BEGIN
        _navigation_stack := SLICE(_navigation_stack, 0, LENGTH(_navigation_stack) - 2);
        SET('_navigation_stack', _navigation_stack);
        SAVE_STATE('navigation_stack', _navigation_stack);
        RETURN _navigation_stack[LENGTH(_navigation_stack) - 1];
    END ELSE
        RETURN 'home';
END;

GO_BACK() := BEGIN
    previous_route := POP_ROUTE();
    NAVIGATE(previous_route);
    RETURN previous_route;
END;

GO_TO(route) := BEGIN
    PUSH_ROUTE(route);
    NAVIGATE(route);
END;

CAN_GO_BACK() := LENGTH(_navigation_stack) > 1;

-- ============================================
-- Theme
-- ============================================
_is_dark_mode := LOAD_STATE('is_dark_mode', FALSE);

TOGGLE_DARK_MODE() := BEGIN
    _is_dark_mode := NOT _is_dark_mode;
    SAVE_STATE('is_dark_mode', _is_dark_mode);
    SET('_is_dark_mode', _is_dark_mode);
END;

SET_DARK_MODE(enabled) := BEGIN
    _is_dark_mode := enabled;
    SAVE_STATE('is_dark_mode', enabled);
    SET('_is_dark_mode', enabled);
END;

-- ============================================
-- Onboarding
-- ============================================
_analytics_enabled := LOAD_STATE('analytics_enabled', FALSE);
_crashlytics_enabled := LOAD_STATE('crashlytics_enabled', FALSE);
_location_enabled := LOAD_STATE('location_enabled', FALSE);
_onboarding_completed := LOAD_STATE('onboarding_completed', FALSE);

SET_ANALYTICS_CONSENT(enabled) := BEGIN
    _analytics_enabled := enabled;
    SAVE_STATE('analytics_enabled', enabled);
END;

SET_CRASHLYTICS_CONSENT(enabled) := BEGIN
    _crashlytics_enabled := enabled;
    SAVE_STATE('crashlytics_enabled', enabled);
END;

SET_LOCATION_CONSENT(enabled) := BEGIN
    _location_enabled := enabled;
    SAVE_STATE('location_enabled', enabled);
END;

COMPLETE_ONBOARDING() := BEGIN
    _onboarding_completed := TRUE;
    SAVE_STATE('onboarding_completed', TRUE);
END;

IS_ONBOARDING_COMPLETED() := _onboarding_completed;

RESET_ONBOARDING() := BEGIN
    _onboarding_completed := FALSE;
    SAVE_STATE('onboarding_completed', FALSE);
    GO_TO('onboarding');
END;

-- ============================================
-- API Configuration
-- ============================================
_api_key := LOAD_STATE('api_key', '');
_api_host := LOAD_STATE('api_host', 'www.superheroapi.com');

SET_API_KEY(key) := BEGIN
    _api_key := key;
    SAVE_STATE('api_key', key);
    SET('_api_key', key);
END;

SET_API_HOST(host) := BEGIN
    _api_host := host;
    SAVE_STATE('api_host', host);
    SET('_api_host', host);
END;

-- ============================================
-- Hero Statistics
-- ============================================
-- Running totals for O(1) avg/stdev derivation
_height_total := 0;
_height_sq_total := 0;
_height_count := 0;
_weight_total := 0;
_weight_sq_total := 0;
_weight_count := 0;

-- Running total: sum of strength across all heroes
_total_fighting_power := 0;

-- Derived statistics (recomputed from running totals via DERIVE_STATS)
_height_avg := 0;
_height_stdev := 0;
_weight_avg := 0;
_weight_stdev := 0;

-- Derive avg and stdev from running totals. O(1).
-- avg = total/count, stdev = sqrt(E[X²] - E[X]²)
-- No SET() needed — these are consumed within SHQL™; onMutated fires from eval().
DERIVE_STATS() := BEGIN
    _height_avg := IF _height_count = 0 THEN 0 ELSE _height_total / _height_count;
    __hvar := IF _height_count = 0 THEN 0 ELSE _height_sq_total / _height_count - _height_avg * _height_avg;
    _height_stdev := IF __hvar <= 0 THEN 0 ELSE POW(__hvar, 0.5);
    _weight_avg := IF _weight_count = 0 THEN 0 ELSE _weight_total / _weight_count;
    __wvar := IF _weight_count = 0 THEN 0 ELSE _weight_sq_total / _weight_count - _weight_avg * _weight_avg;
    _weight_stdev := IF __wvar <= 0 THEN 0 ELSE POW(__wvar, 0.5);
END;

-- Incremental: hero added to collection. O(1).
-- Null height/weight values are skipped (no contribution to totals).
STATS_HERO_ADDED(__hero) := BEGIN
    __ht := HEIGHT_M(__hero, null);
    IF __ht <> null THEN BEGIN
        _height_total := _height_total + __ht;
        _height_sq_total := _height_sq_total + __ht * __ht;
        _height_count := _height_count + 1;
    END;
    __wt := WEIGHT_KG(__hero, null);
    IF __wt <> null THEN BEGIN
        _weight_total := _weight_total + __wt;
        _weight_sq_total := _weight_sq_total + __wt * __wt;
        _weight_count := _weight_count + 1;
    END;
    _total_fighting_power := _total_fighting_power + POWERSTATS(__hero, p => p.strength, 0);
    DERIVE_STATS();
END;

-- Incremental: hero removed from collection. O(1).
-- Null height/weight values are skipped (they never contributed).
STATS_HERO_REMOVED(__hero) := BEGIN
    __ht := HEIGHT_M(__hero, null);
    IF __ht <> null THEN BEGIN
        _height_total := _height_total - __ht;
        _height_sq_total := _height_sq_total - __ht * __ht;
        _height_count := _height_count - 1;
    END;
    __wt := WEIGHT_KG(__hero, null);
    IF __wt <> null THEN BEGIN
        _weight_total := _weight_total - __wt;
        _weight_sq_total := _weight_sq_total - __wt * __wt;
        _weight_count := _weight_count - 1;
    END;
    _total_fighting_power := _total_fighting_power - POWERSTATS(__hero, p => p.strength, 0);
    DERIVE_STATS();
END;

-- Incremental: hero replaced (amend/update). O(1).
-- Either side's height/weight can be null (no-op for that dimension).
STATS_HERO_REPLACED(__old, __new) := BEGIN
    STATS_HERO_REMOVED(__old);
    STATS_HERO_ADDED(__new);
END;

-- Reset all running totals to zero. For clear-all-data.
STATS_CLEAR() := BEGIN
    _height_total := 0;
    _height_sq_total := 0;
    _height_count := 0;
    _weight_total := 0;
    _weight_sq_total := 0;
    _weight_count := 0;
    _total_fighting_power := 0;
    DERIVE_STATS();
END;

-- ============================================
-- Filters & Predicates
-- ============================================

-- Named filters (persisted). Each filter is OBJECT{name, predicate}.
-- Defaults: Heroes, Villains, Giants, Dwarves, Read Heads, Obsese, Strong Villains, Dumb Villains, Non-Males and Troglodytes.
-- Use RESET_PREDICATES() to restore them.
-- "Giants" anmd "Dwarves" demonstrate computed predicates (height > avg + 2*stdev and height < avg-2*stdev, respectively)
_DEFAULT_FILTERS := [
    OBJECT{name: "Heroes", predicate: "biography.alignment <= good"},
    OBJECT{name: "Villains", predicate: "biography.alignment > good"},
    OBJECT{name: "Giants", predicate: "appearance.height.m > _height_avg + 2 * _height_stdev"},
    OBJECT{name: "Dwarves", predicate: "appearance.height.m < _height_avg - 2 * _height_stdev"},
    OBJECT{name: "Red Heads", predicate: 'appearance.hair_colour ~ "red"'},
    OBJECT{name: "Obese", predicate: "appearance.weight.kg / POW(appearance.height.m, 2) >= 30"},
    OBJECT{name: "Strong Villains", predicate: "biography.alignment > reasonable AND powerstats.strength >= powerstats.intelligence*1.1"},
    OBJECT{name: "Dumb Villains", predicate: "biography.alignment >= bad AND powerstats.intelligence <= 50"},
    OBJECT{name: "Non-Males", predicate: "appearance.gender <> male"},
    OBJECT{name: "Troglodytes", predicate: 'work.base ~ "cave"'}
];
_filters := LOAD_STATE('filters', _DEFAULT_FILTERS);
_filter_counts := [];
_filtered_heroes := [];
_filter_lambdas := {};
_active_filter_index := -1;
_displayed_heroes := [];
_current_query := '';

-- Rebuild all filter result maps from scratch. Called after filter CRUD
-- or batch operations (reconcile, init). Each _filtered_heroes[i] is a
-- map keyed by hero ID for O(1) add/remove.
-- Apply a predicate to a hero list, returning a map of matching heroes keyed by ID.
-- Single place for predicate-based filtering — used by REBUILD_ALL_FILTERS,
-- ON_HERO_ADDED, and FILTER_DISPLAYED.
-- Calls predicate lambdas directly in SHQL (no Dart roundtrip).
-- Falls back to text-match via MATCH() when pred is null.
APPLY_PREDICATE(__hero_list, __pred, __predText) := BEGIN
    __result := {};
    IF LENGTH(__hero_list) > 0 THEN
        FOR __j := 0 TO LENGTH(__hero_list) - 1 DO BEGIN
            __hero := __hero_list[__j];
            __match := IF __pred <> null THEN __pred(__hero) ELSE MATCH(__hero, __predText);
            IF __match THEN
                __result[__hero.ID] := __hero;
        END;
    RETURN __result;
END;

REBUILD_ALL_FILTERS() := BEGIN
    __hero_list := MAP_VALUES(_heroes);
    _filtered_heroes := [];
    _filter_counts := [];
    DEBUG_LOG('[REBUILD] start: ' + STRING(LENGTH(_filters)) + ' filters, ' + STRING(LENGTH(__hero_list)) + ' heroes');
    FOR __i := 0 TO LENGTH(_filters) - 1 DO BEGIN
        __predText := _filters[__i].PREDICATE;
        __fname := _filters[__i].NAME;
        __pred := IF __predText = '' OR __predText = null THEN null ELSE _filter_lambdas[__fname];
        DEBUG_LOG('[REBUILD]   [' + STRING(__i) + '] name="' + __fname + '" pred=' + IF __pred <> null THEN 'lambda' ELSE 'NULL' + ' predText="' + __predText + '"');
        __result := APPLY_PREDICATE(__hero_list, __pred, __predText);
        _filtered_heroes := _filtered_heroes + [__result];
        _filter_counts := _filter_counts + [LENGTH(__result)];
        DEBUG_LOG('[REBUILD]   [' + STRING(__i) + '] name="' + __fname + '" count=' + STRING(LENGTH(__result)));
    END;
    SET('_filter_counts', _filter_counts);
    DEBUG_LOG('[REBUILD] done: counts=' + STRING(_filter_counts));
END;

-- Update _displayed_heroes from the active filter or full hero map.
-- Always produces a list (via MAP_VALUES) for card generation.
UPDATE_DISPLAYED_HEROES() := BEGIN
    IF _active_filter_index < 0 OR _active_filter_index >= LENGTH(_filtered_heroes) THEN
        _displayed_heroes := MAP_VALUES(_heroes)
    ELSE
        _displayed_heroes := MAP_VALUES(_filtered_heroes[_active_filter_index]);
    SET('_displayed_heroes', _displayed_heroes);
END;

-- Filter _heroes by a compiled predicate and update _displayed_heroes.
-- Called from Dart after compiling a text query or SHQL™ expression.
FILTER_DISPLAYED(__pred, __predText) := BEGIN
    __matched := APPLY_PREDICATE(MAP_VALUES(_heroes), __pred, __predText);
    _displayed_heroes := MAP_VALUES(__matched);
    SET('_displayed_heroes', _displayed_heroes);
END;

-- Apply a filter by index (-1 = All, 0+ = index into filter arrays).
-- Clears any active text query (filters and text queries are mutually exclusive).
APPLY_FILTER(index) := BEGIN
    _active_filter_index := index;
    _current_query := '';
    SET('_active_filter_index', _active_filter_index);
    SET('_current_query', _current_query);
    UPDATE_DISPLAYED_HEROES();
END;

-- Save or update a named filter. If name exists, updates its predicate in place.
SAVE_FILTER(name, predicate) := BEGIN
    new_filters := [];
    found := FALSE;
    FOR i := 0 TO LENGTH(_filters) - 1 DO BEGIN
        IF _filters[i].name = name THEN BEGIN
            new_filters := new_filters + [OBJECT{name: name, predicate: predicate}];
            found := TRUE;
        END ELSE
            new_filters := new_filters + [_filters[i]];
    END;
    _filters := IF found THEN new_filters ELSE _filters + [OBJECT{name: name, predicate: predicate}];
    SAVE_STATE('filters', _filters);
    SET('_filters', _filters);
END;

-- Delete any filter by index. All filters are user-defined and deletable.
-- Use RESET_PREDICATES() to restore the defaults.
DELETE_FILTER(index) := BEGIN
    IF index < 0 OR index >= LENGTH(_filters) THEN RETURN;
    new_filters := [];
    FOR i := 0 TO LENGTH(_filters) - 1 DO
        IF i <> index THEN
            new_filters := new_filters + [_filters[i]];
    _filters := new_filters;
    SAVE_STATE('filters', _filters);
    SET('_filters', _filters);
    IF _active_filter_index >= LENGTH(_filters) OR _active_filter_index = index THEN
        APPLY_FILTER(-1);
END;

-- Reset to the three default filters. Replaces the entire list.
RESET_PREDICATES() := BEGIN
    _filters := _DEFAULT_FILTERS;
    SAVE_STATE('filters', _filters);
    SET('_filters', _filters);
    APPLY_FILTER(-1);
END;

-- Add a new empty filter and select it for editing
ADD_FILTER() := BEGIN
    SAVE_FILTER('New Filter', '');
    APPLY_FILTER(LENGTH(_filters) - 1);
END;

-- Rename a filter by index
RENAME_FILTER(index, new_name) := BEGIN
    IF index < 0 OR index >= LENGTH(_filters) THEN RETURN;
    old := _filters[index];
    new_filters := [];
    FOR i := 0 TO LENGTH(_filters) - 1 DO
        IF i = index THEN
            new_filters := new_filters + [OBJECT{name: new_name, predicate: old.predicate}]
        ELSE
            new_filters := new_filters + [_filters[i]];
    _filters := new_filters;
    SAVE_STATE('filters', _filters);
    SET('_filters', _filters);
END;

-- Apply an ad-hoc query without saving it as a named filter
APPLY_QUERY(expression) := BEGIN
    _current_query := expression;
    _active_filter_index := -1;
    SET('_current_query', _current_query);
    SET('_active_filter_index', _active_filter_index);
END;

-- _filter_counts[i] corresponds to _filters[i] (set by REBUILD_ALL_FILTERS).
GET_FILTER_COUNT(index) := IF index < 0 OR index >= LENGTH(_filter_counts) THEN 0 ELSE _filter_counts[index];

-- Generate filter list items for home screen (one per named filter)
GENERATE_FILTER_COUNTER_CARDS() := BEGIN
    result := [];
    _icons := ['shield', 'dangerous'];
    _colors := ['0xFF2196F3', '0xFFF44336'];

    FOR i := 0 TO LENGTH(_filters) - 1 DO BEGIN
        count := IF i < LENGTH(_filter_counts) THEN _filter_counts[i] ELSE 0;
        icon := IF i < LENGTH(_icons) THEN _icons[i] ELSE 'label';
        color := IF i < LENGTH(_colors) THEN _colors[i] ELSE '0xFF9E9E9E';
        name := _filters[i].name;

        item := {
            "type": "Card",
            "props": {
                "onTap": "shql: APPLY_FILTER(" + STRING(i) + "); GO_TO('heroes')",
                "child": {
                    "type": "Padding",
                    "props": {
                        "padding": 8,
                        "child": {
                            "type": "Row",
                            "props": {
                                "children": [
                                    {"type": "Icon", "props": {"icon": icon, "color": color, "size": 20}},
                                    {"type": "SizedBox", "props": {"width": 12}},
                                    {"type": "Expanded", "child": {"type": "Text", "props": {"data": name}}},
                                    {"type": "Text", "props": {"data": STRING(count), "style": {"fontWeight": "bold", "fontSize": 16}}}
                                ]
                            }
                        }
                    }
                }
            }
        };
        result := result + [item];
    END;
    RETURN result;
END;

-- ============================================
-- Hero Collection
-- ============================================
_heroes := {};
_selected_hero := null;
_hero_cards := [];
_is_loading := FALSE;
_error_message := '';
_total_heroes := 0;
_reconcile_active := FALSE;
_reconcile_aborted := FALSE;
_reconcile_current := '';
_reconcile_status := '';
_reconcile_log := [];

-- Abort an in-progress reconciliation (checked each iteration by Dart)
ABORT_RECONCILE() := BEGIN
    _reconcile_aborted := TRUE;
    SET('_reconcile_aborted', _reconcile_aborted);
END;

-- Notify YAML Observers that watch hero/filter/stats variables.
-- Observer uses addListener, so SET() is required for UI updates.
_NOTIFY_HERO_STATE() := BEGIN
    SET('_heroes', _heroes);
    SET('_total_heroes', _total_heroes);
    SET('_total_fighting_power', _total_fighting_power);
    SET('_filter_counts', _filter_counts);
END;

-- Hero added to collection. Updates heroes map, running stats, and filter
-- membership in one call. O(filters).
-- During init _filtered_heroes is [] so the filter block is guarded.
ON_HERO_ADDED(__hero) := BEGIN
    _heroes[__hero.ID] := __hero;
    _total_heroes := LENGTH(_heroes);
    STATS_HERO_ADDED(__hero);
    IF LENGTH(_filtered_heroes) > 0 THEN
        FOR __i := 0 TO LENGTH(_filtered_heroes) - 1 DO BEGIN
            __predText := _filters[__i].PREDICATE;
            __fname := _filters[__i].NAME;
            IF __predText = '' OR __predText = null THEN
                _filtered_heroes[__i][__hero.ID] := __hero
            ELSE BEGIN
                __pred := _filter_lambdas[__fname];
                __match := IF __pred <> null THEN __pred(__hero) ELSE MATCH(__hero, __predText);
                IF __match THEN
                    _filtered_heroes[__i][__hero.ID] := __hero;
            END;
            _filter_counts[__i] := LENGTH(_filtered_heroes[__i]);
            DEBUG_LOG('[ON_HERO_ADDED] [' + STRING(__i) + '] "' + __fname + '" count=' + STRING(_filter_counts[__i]));
        END;
    _NOTIFY_HERO_STATE();
END;

-- Hero removed from collection. O(filters).
ON_HERO_REMOVED(__hero) := BEGIN
    MAP_REMOVE(_heroes, __hero.ID);
    _total_heroes := LENGTH(_heroes);
    STATS_HERO_REMOVED(__hero);
    IF LENGTH(_filtered_heroes) > 0 THEN
        FOR __i := 0 TO LENGTH(_filtered_heroes) - 1 DO BEGIN
            MAP_REMOVE(_filtered_heroes[__i], __hero.ID);
            _filter_counts[__i] := LENGTH(_filtered_heroes[__i]);
        END;
    _NOTIFY_HERO_STATE();
END;

-- Hero replaced (amend/update). Removes old, adds new. O(filters).
-- ON_HERO_REMOVED + ON_HERO_ADDED each notify; harmless double-notify.
ON_HERO_REPLACED(__old, __new) := BEGIN
    ON_HERO_REMOVED(__old);
    ON_HERO_ADDED(__new);
END;

-- Clear all heroes. Resets heroes map, stats, and all filter result maps.
ON_HERO_CLEAR() := BEGIN
    _heroes := {};
    _total_heroes := 0;
    STATS_CLEAR();
    IF LENGTH(_filtered_heroes) > 0 THEN
        FOR __i := 0 TO LENGTH(_filtered_heroes) - 1 DO BEGIN
            _filtered_heroes[__i] := {};
            _filter_counts[__i] := 0;
        END;
    _NOTIFY_HERO_STATE();
END;

-- Select a hero for detail view
SELECT_HERO(hero) := BEGIN
    _selected_hero := hero;
    SET('_selected_hero', hero);
    GO_TO('hero_detail');
END;

-- Save a hero to local database (extracts external_id from SHQL™ object)
SAVE_HERO(hero) := BEGIN
    _PERSIST_HERO(hero.external_id);
END;

-- Nullary function SHQL™ wrappers.
-- Native nullary functions are registered as _CLEAR_ALL_DATA, _RECONCILE_HEROES.
-- We wrap them so SHQL™ can call them with FOO() syntax (the parser always
-- creates call(identifier, tuple) for FOO(), but IdentifierExecutionNode
-- correctly executes nullary functions when referenced WITHOUT parentheses).
CLEAR_ALL_DATA() := _CLEAR_ALL_DATA;
RECONCILE_HEROES() := _RECONCILE_HEROES;
SIGN_OUT() := _SIGN_OUT;

-- Toggle hero lock state (lock/unlock for reconciliation)
-- (native implementation in Dart via _TOGGLE_LOCK_HERO unary function)

GET_HERO_COUNT() := LENGTH(_heroes);

-- ============================================
-- Hero Detail Helpers (used by GENERATE_HERO_DETAIL)
-- ============================================

-- Wrap children in a Card with a section title, with padding.
_MAKE_DETAIL_CARD(section_title, children) := {
    "type": "Padding",
    "props": {
        "padding": {"left": 16, "right": 16, "bottom": 16},
        "child": {
            "type": "Card",
            "props": {
                "child": {
                    "type": "Padding",
                    "props": {
                        "padding": 16,
                        "child": {
                            "type": "Column",
                            "props": {
                                "crossAxisAlignment": "start",
                                "children": [{"type": "Text", "props": {"data": section_title, "style": {"fontSize": 18, "fontWeight": "bold"}}}, {"type": "SizedBox", "props": {"height": 12}}] + children
                            }
                        }
                    }
                }
            }
        }
    }
};

-- A single stat widget: big colored number with label
_MAKE_STAT_WIDGET(fld, hero) := {
    "type": "Expanded",
    "child": {
        "type": "Column",
        "children": [
            {"type": "Text", "props": {"data": fld.LABEL, "style": {"fontSize": 12, "color": "0xFF757575"}}},
            {"type": "Text", "props": {"data": (IF hero <> null THEN STRING(fld.ACCESSOR(hero)) ELSE '-'), "style": {"fontSize": 24, "fontWeight": "bold", "color": fld.COLOR}}}
        ]
    }
};

-- A label:value text row
_MAKE_TEXT_ROW(fld, hero) := [
    {"type": "Row", "children": [
        {"type": "Text", "props": {"data": fld.LABEL + ": ", "style": {"fontWeight": "bold"}}},
        {"type": "Expanded", "child": {"type": "Text", "props": {"data": (IF hero <> null THEN STRING(fld.ACCESSOR(hero)) ELSE 'Unknown')}}}
    ]},
    {"type": "SizedBox", "props": {"height": 8}}
];

-- An enum label:value row (uses a label list for display)
_MAKE_ENUM_ROW(fld, hero) := [
    {"type": "Row", "children": [
        {"type": "Text", "props": {"data": fld.LABEL + ": ", "style": {"fontWeight": "bold"}}},
        {"type": "Expanded", "child": {"type": "Text", "props": {"data": (IF hero <> null THEN fld.ENUM_LABELS[fld.ACCESSOR(hero)] ELSE 'Unknown')}}}
    ]},
    {"type": "SizedBox", "props": {"height": 8}}
];

-- A measurement label:value row (height/weight with unit suffix and > 0 check)
_MAKE_MEASUREMENT_ROW(fld, hero) := [
    {"type": "Row", "children": [
        {"type": "Text", "props": {"data": fld.LABEL + ": ", "style": {"fontWeight": "bold"}}},
        {"type": "Expanded", "child": {"type": "Text", "props": {"data": (IF hero <> null AND fld.ACCESSOR(hero) > 0 THEN STRING(fld.ACCESSOR(hero)) + ' ' + fld.UNIT ELSE 'Unknown')}}}
    ]},
    {"type": "SizedBox", "props": {"height": 8}}
];

-- ============================================
-- GENERATE_HERO_DETAIL: data-driven detail view
-- ============================================
-- Iterates _detail_fields metadata and builds the full detail body widget tree.
-- Hero image & alignment badge at top, then one Card per section.
GENERATE_HERO_DETAIL() := BEGIN
    hero := _selected_hero;
    IF hero = null THEN RETURN {"type": "SizedBox"};

    result := [];

    -- Hero Image
    __img_url := IMAGE(hero, img => img.url, null);
    __img_widget := IF __img_url <> null THEN
        {"type": "Image", "props": {"src": __img_url, "fit": "contain"}}
    ELSE
        {"type": "Icon", "props": {"icon": "person", "size": 100, "color": "0xFF757575"}};
    result := result + [{"type": "Container", "props": {"height": 300, "color": "0xFF212121", "child": __img_widget}}];

    -- Alignment Badge
    __align := BIOGRAPHY(hero, b => b.alignment, 0);
    __badge_color := IF __align <= GOOD THEN '0xFF2196F3' ELSE IF __align >= BAD THEN '0xFFF44336' ELSE '0xFF9E9E9E';
    __badge_text := UPPERCASE(_ALIGNMENT_LABELS[__align]);
    result := result + [{
        "type": "Container",
        "props": {
            "transform": "translate(0, -20)",
            "alignment": "center",
            "child": {
                "type": "Container",
                "props": {
                    "padding": {"horizontal": 24, "vertical": 8},
                    "decoration": {"color": __badge_color, "borderRadius": 20},
                    "child": {"type": "Text", "props": {"data": __badge_text, "style": {"color": "0xFFFFFFFF", "fontWeight": "bold"}}}
                }
            }
        }
    }];

    -- Iterate _detail_fields grouped by section
    current_section := '';
    section_children := [];
    stat_widgets := [];

    FOR __i := 0 TO LENGTH(_detail_fields) - 1 DO BEGIN
        fld := _detail_fields[__i];

        -- When section changes, flush the previous section
        IF fld.SECTION <> current_section THEN BEGIN
            IF current_section <> '' THEN BEGIN
                -- If the previous section had stats, lay them out in rows of 3
                IF LENGTH(stat_widgets) > 0 THEN BEGIN
                    section_children := [{"type": "SizedBox", "props": {"height": 4}}];
                    __row := [];
                    FOR __s := 0 TO LENGTH(stat_widgets) - 1 DO BEGIN
                        __row := __row + [stat_widgets[__s]];
                        IF LENGTH(__row) = 3 OR __s = LENGTH(stat_widgets) - 1 THEN BEGIN
                            section_children := section_children + [{"type": "Row", "children": __row}];
                            IF __s < LENGTH(stat_widgets) - 1 THEN
                                section_children := section_children + [{"type": "SizedBox", "props": {"height": 16}}];
                            __row := [];
                        END;
                    END;
                END;
                result := result + [_MAKE_DETAIL_CARD(current_section, section_children)];
            END;
            current_section := fld.SECTION;
            section_children := [];
            stat_widgets := [];
        END;

        -- Build widget based on display_type
        IF fld.DISPLAY_TYPE = 'stat' THEN
            stat_widgets := stat_widgets + [_MAKE_STAT_WIDGET(fld, hero)]
        ELSE IF fld.DISPLAY_TYPE = 'enum_label' THEN
            section_children := section_children + _MAKE_ENUM_ROW(fld, hero)
        ELSE IF fld.DISPLAY_TYPE = 'measurement' THEN
            section_children := section_children + _MAKE_MEASUREMENT_ROW(fld, hero)
        ELSE
            section_children := section_children + _MAKE_TEXT_ROW(fld, hero);
    END;

    -- Flush last section
    IF current_section <> '' THEN BEGIN
        IF LENGTH(stat_widgets) > 0 THEN BEGIN
            section_children := [{"type": "SizedBox", "props": {"height": 4}}];
            __row := [];
            FOR __s := 0 TO LENGTH(stat_widgets) - 1 DO BEGIN
                __row := __row + [stat_widgets[__s]];
                IF LENGTH(__row) = 3 OR __s = LENGTH(stat_widgets) - 1 THEN BEGIN
                    section_children := section_children + [{"type": "Row", "children": __row}];
                    IF __s < LENGTH(stat_widgets) - 1 THEN
                        section_children := section_children + [{"type": "SizedBox", "props": {"height": 16}}];
                    __row := [];
                END;
            END;
        END;
        result := result + [_MAKE_DETAIL_CARD(current_section, section_children)];
    END;

    result := result + [{"type": "SizedBox", "props": {"height": 24}}];

    RETURN {"type": "SingleChildScrollView", "props": {"child": {"type": "Column", "props": {"crossAxisAlignment": "stretch", "children": result}}}};
END;

-- ============================================
-- Hero Card Generation (data-driven from _summary_fields)
-- ============================================
-- source: the SHQL™ variable name as a string, e.g. '_heroes' or '_search_results'
-- deletable: TRUE for saved heroes (show trash can), FALSE for search results
GENERATE_HERO_CARDS(heroes, source, deletable) := BEGIN
    result := [];
    IF LENGTH(heroes) = 0 THEN
        RETURN result;

    FOR i := 0 TO LENGTH(heroes) - 1 DO BEGIN
        hero := heroes[i];
        props := {};
        props["stats"] := [];
        FOR __j := 0 TO LENGTH(_summary_fields) - 1 DO BEGIN
            __sf := _summary_fields[__j];
            IF __sf.IS_STAT THEN
                props["stats"] := props["stats"] + [OBJECT{value: __sf.ACCESSOR(hero), label: __sf.LABEL, color: __sf.COLOR}]
            ELSE
                props[__sf.PROP_NAME] := __sf.ACCESSOR(hero);
        END;
        props["onTap"] := "shql: SELECT_HERO(" + source + "[" + STRING(i) + "])";
        IF deletable THEN
            props["onDelete"] := "shql: DELETE_HERO('" + hero.id + "')";
        result := result + [{"type": "HeroCard", "props": props}];
    END;
    RETURN result;
END;

-- Generate saved heroes list (uses _displayed_heroes which is filtered by active filter)
GENERATE_SAVED_HEROES_CARDS() := BEGIN
    IF LENGTH(_heroes) = 0 THEN
        RETURN [{
            "type": "Center",
            "child": {
                "type": "Column",
                "props": {
                    "mainAxisAlignment": "center",
                    "children": [
                        {
                            "type": "Icon",
                            "props": {
                                "icon": "bookmark_border",
                                "size": 64,
                                "color": "0xFF9E9E9E"
                            }
                        },
                        {
                            "type": "SizedBox",
                            "props": { "height": 16 }
                        },
                        {
                            "type": "Text",
                            "props": {
                                "data": "No heroes saved yet",
                                "style": { "fontSize": 18 }
                            }
                        },
                        {
                            "type": "SizedBox",
                            "props": { "height": 8 }
                        },
                        {
                            "type": "Text",
                            "props": {
                                "data": "Search and save heroes to build your database!",
                                "style": { "color": "0xFF9E9E9E" }
                            }
                        }
                    ]
                }
            }
        }];

    -- If filter/query is active but no heroes match, show an appropriate message
    IF LENGTH(_displayed_heroes) = 0 AND (_active_filter_index >= 0 OR NOT (IS_NULL_OR_WHITESPACE(_current_query))) THEN BEGIN
        __empty_msg := IF NOT (IS_NULL_OR_WHITESPACE(_current_query)) THEN 'No heroes match "' + _current_query + '"' ELSE 'No heroes match this filter';
        RETURN [{
            "type": "Center",
            "child": {
                "type": "Text",
                "props": {
                    "data": __empty_msg,
                    "style": { "fontSize": 16, "color": "0xFF757575" }
                }
            }
        }];
    END;

    RETURN GENERATE_HERO_CARDS(_displayed_heroes, '_displayed_heroes', TRUE);
END;

-- Generate a single saved hero card (used by Dart per-ID cache).
-- Uses ID-based lookup from _heroes so no display index is needed.
GENERATE_SINGLE_HERO_CARD(__hero) := BEGIN
    props := {};
    props["stats"] := [];
    FOR __j := 0 TO LENGTH(_summary_fields) - 1 DO BEGIN
        __sf := _summary_fields[__j];
        IF __sf.IS_STAT THEN
            props["stats"] := props["stats"] + [OBJECT{value: __sf.ACCESSOR(__hero), label: __sf.LABEL, color: __sf.COLOR}]
        ELSE
            props[__sf.PROP_NAME] := __sf.ACCESSOR(__hero);
    END;
    props["onTap"] := "shql: SELECT_HERO(_heroes['" + __hero.ID + "'])";
    props["onDelete"] := "shql: DELETE_HERO('" + __hero.ID + "')";
    props["locked"] := __hero.LOCKED;
    props["onToggleLock"] := "shql: _TOGGLE_LOCK_HERO('" + __hero.ID + "')";
    RETURN {"type": "HeroCard", "props": props};
END;

-- ============================================
-- Hero Search
-- ============================================
_search_results := [];
_search_query := '';
_search_history := LOAD_STATE('search_history', []);
-- Search summary (set by Dart after dialog-based save flow)
_search_summary := '';

-- Search for heroes via API
SEARCH_HEROES(query) := BEGIN
    IF LENGTH(query) < 2 THEN BEGIN
        _search_results := [];
        SET('_search_results', []);
        RETURN [];
    END;

    _search_query := query;
    _is_loading := TRUE;
    SET('_is_loading', TRUE);

    -- Add to search history
    IF NOT (query IN _search_history) THEN BEGIN
        _search_history := [query] + SLICE(_search_history, 0, 9);
        SAVE_STATE('search_history', _search_history);
    END;

    -- Call native Dart function to perform the actual API fetch
    _FETCH_HEROES(query);

    RETURN _search_query;
END;

-- Clear search results
CLEAR_SEARCH() := BEGIN
    _search_results := [];
    _search_query := '';
    SET('_search_results', []);
    SET('_search_query', '');
END;

-- Generate search result cards
GENERATE_SEARCH_CARDS() := BEGIN
    IF LENGTH(_search_results) = 0 THEN
        RETURN [{
            "type": "Center",
            "child": {
                "type": "Text",
                "props": {
                    "data": "No results found"
                }
            }
        }];

    RETURN GENERATE_HERO_CARDS(_search_results, '_search_results', FALSE);
END;

-- Generate search history chips
GENERATE_SEARCH_HISTORY() := BEGIN
    result := [];
    IF LENGTH(_search_history) = 0 THEN
        RETURN result;

    FOR i := 0 TO LENGTH(_search_history) - 1 DO BEGIN
        query := _search_history[i];
        result := result + [{
            "type": "ActionChip",
            "props": {
                "label": query,
                "onPressed": "shql: SEARCH_HEROES('" + query + "')"
            }
        }];
    END;
    RETURN result;
END;

-- ============================================
-- Hero Edit
-- ============================================
-- Edit hero form state (list of field descriptors, populated by _PREPARE_EDIT Dart callback)
_edit_fields := [];

-- Prepare edit form generically from the hero's Field hierarchy (Dart walks the tree)
-- and navigate to the edit screen.
EDIT_HERO() := BEGIN
    _PREPARE_EDIT;
    GO_TO('hero_edit');
END;

-- Submit amendments to native code
SAVE_AMENDMENTS() := BEGIN
    _APPLY_AMENDMENT(_selected_hero.id);
END;

-- Generate the edit form dynamically from _edit_fields (set by _PREPARE_EDIT).
-- Each field descriptor is OBJECT{section, label, json_section, json_name,
-- field_type ("string"|"enum"|"number"), value, original, options (list for enums)}.
-- Groups fields by section, producing a Card per Amendable sub-model.
GENERATE_EDIT_FORM() := BEGIN
    result := [];
    IF _edit_fields = null OR LENGTH(_edit_fields) = 0 THEN
        RETURN result;

    current_section := '';

    FOR i := 0 TO LENGTH(_edit_fields) - 1 DO BEGIN
        fld := _edit_fields[i];

        -- Section header when section changes (each Amendable gets its own Card-like header)
        IF fld.SECTION <> current_section AND fld.SECTION <> '' THEN BEGIN
            current_section := fld.SECTION;
            -- Add spacing + section header
            result := result + [
                {"type": "SizedBox", "props": {"height": 24}},
                {"type": "Text", "props": {
                    "data": current_section,
                    "style": {"fontSize": 16, "fontWeight": "bold", "color": "0xFF1976D2"}
                }},
                {"type": "SizedBox", "props": {"height": 8}}
            ];
        END;

        -- Field label
        result := result + [
            {"type": "Text", "props": {
                "data": fld.LABEL,
                "style": {"fontWeight": "bold", "fontSize": 14}
            }},
            {"type": "SizedBox", "props": {"height": 4}}
        ];

        -- Widget depends on field_type
        IF fld.FIELD_TYPE = 'enum' THEN BEGIN
            -- Dropdown for enum fields
            result := result + [
                {"type": "DropdownButton", "props": {
                    "items": fld.OPTIONS,
                    "value": fld.VALUE,
                    "hint": "Select " + fld.LABEL,
                    "onChanged": "shql: _edit_fields[" + STRING(i) + "].VALUE := value"
                }}
            ];
        END ELSE BEGIN
            -- TextField for string/number fields
            result := result + [
                {"type": "TextField", "props": {
                    "initialValue": fld.VALUE,
                    "decoration": {"border": "outline"},
                    "onChanged": "shql: _edit_fields[" + STRING(i) + "].VALUE := value"
                }}
            ];
        END;

        result := result + [{"type": "SizedBox", "props": {"height": 16}}];
    END;

    RETURN result;
END;

-- ============================================
-- Weather
-- ============================================
_weather_temp := null;
_weather_description := '';
_weather_icon := 'cloud';
_weather_wind := 0;

REFRESH_WEATHER() := BEGIN
    _FETCH_WEATHER();
END;

-- ============================================
-- Location & Battle Map
-- ============================================
_location_description := '';
_user_latitude := 56.28;
_user_longitude := 13.28;
_battle_locations := [];

GENERATE_BATTLE_LOCATIONS() := BEGIN
    result := [];
    __hero_list := MAP_VALUES(_heroes);
    FOR i := 0 TO LENGTH(__hero_list) - 1 DO BEGIN
        hero := __hero_list[i];
        name := NVL(hero, h => h.name, "Unknown");
        alignment := BIOGRAPHY(hero, b => b.alignment, NEUTRAL);
        -- Spread heroes around user location using a simple deterministic offset
        -- based on the hero index to avoid all markers stacking
        angle := i * 2.39996;  --- golden angle in radians
        radius := 0.05 + (i % 7) * 0.02;
        lat := _user_latitude + radius * COS(angle);
        lon := _user_longitude + radius * SIN(angle);
        marker := OBJECT{
            lat: lat,
            lon: lon,
            name: name,
            type: IF alignment <= GOOD THEN "hero" ELSE "villain"
        };
        result := result + [marker];
    END;
    RETURN result;
END;

-- ============================================
-- War Status
-- ============================================
_war_messages := [
    "The invasion has been pushed back 47%",
    "Heroes are making progress in sector 7",
    "Villains have joined forces against the common enemy",
    "Defense grid holding steady",
    "New recruits arriving daily",
    "Morale is high among the defenders"
];

GET_WAR_STATUS() := BEGIN
    -- Return a "random" message based on current second
    index := INT(_total_heroes) % LENGTH(_war_messages);
    RETURN _war_messages[index];
END;
