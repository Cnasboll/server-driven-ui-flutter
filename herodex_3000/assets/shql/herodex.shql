-- ============================================
-- HeroDex 3000 - SHQL™ Functions
-- ============================================

-- Hero Model Accessors, Value Type Helpers, _detail_fields, and _summary_fields
-- are auto-generated by HeroSchema from the Field tree (loaded before this file).

-- ============================================
-- Navigation
-- ============================================
_tab_routes := ['home', 'online', 'heroes', 'settings'];
_navigation_stack := LOAD_STATE('navigation_stack', ['home']);

TAB_NAV(current, idx) := IF idx <> current THEN GO_TO(_tab_routes[idx]);

PUSH_ROUTE(route) := BEGIN
    IF LENGTH(_navigation_stack) = 0 THEN
        _navigation_stack := [route]
    ELSE BEGIN
        current_route := _navigation_stack[LENGTH(_navigation_stack) - 1];
        IF current_route <> route THEN BEGIN
            IF route IN _navigation_stack THEN
                _navigation_stack := SLICE(_navigation_stack, 0, INDEX_OF(_navigation_stack, route))
            ELSE
                _navigation_stack := _navigation_stack + [route];
        END;
    END;
    SET('_navigation_stack', _navigation_stack);
    SAVE_STATE('navigation_stack', _navigation_stack);
    RETURN _navigation_stack;
END;

POP_ROUTE() := BEGIN
    IF LENGTH(_navigation_stack) > 1 THEN BEGIN
        _navigation_stack := SLICE(_navigation_stack, 0, LENGTH(_navigation_stack) - 2);
        SET('_navigation_stack', _navigation_stack);
        SAVE_STATE('navigation_stack', _navigation_stack);
        RETURN _navigation_stack[LENGTH(_navigation_stack) - 1];
    END ELSE
        RETURN 'home';
END;

GO_BACK() := BEGIN
    previous_route := POP_ROUTE();
    NAVIGATE(previous_route);
    RETURN previous_route;
END;

GO_TO(route) := BEGIN
    PUSH_ROUTE(route);
    NAVIGATE(route);
END;

CAN_GO_BACK() := LENGTH(_navigation_stack) > 1;

-- ============================================
-- Firestore Preferences Sync (pure SHQL™)
-- ============================================
-- Syncs selected preferences to Firestore via REST API (per-user).
-- _FIREBASE_API_KEY and _FIREBASE_PROJECT_ID are defined in auth.shql.
-- _auth_uid is persisted by auth.shql on sign-in.

_auth_uid := LOAD_STATE('_auth_uid', '');

_FIRESTORE_SYNCED_KEYS := ['is_dark_mode', 'api_key', 'api_host',
    'onboarding_completed', 'analytics_enabled', 'crashlytics_enabled',
    'location_enabled', 'filters'];

__FIRESTORE_DOC_URL() := BEGIN
    RETURN 'https://firestore.googleapis.com/v1/projects/' + _FIREBASE_PROJECT_ID
        + '/databases/(default)/documents/preferences/' + _auth_uid;
END;

-- Convert a Dart value to Firestore REST value format.
-- Synced keys are booleans and strings; numbers are stored as stringValue
-- and parsed back via NUMBER() in __FROM_FIRESTORE_VALUE.
__TO_FIRESTORE_VALUE(val) := BEGIN
    __fv := {};
    IF val = TRUE OR val = FALSE THEN BEGIN
        __fv["booleanValue"] := val;
        RETURN __fv;
    END;
    __fv["stringValue"] := STRING(val);
    RETURN __fv;
END;

-- Convert a Firestore REST value back to a Dart value
__FROM_FIRESTORE_VALUE(val) := BEGIN
    IF val["booleanValue"] <> null THEN RETURN val["booleanValue"];
    IF val["integerValue"] <> null THEN RETURN NUMBER(val["integerValue"]);
    IF val["doubleValue"] <> null THEN RETURN val["doubleValue"];
    IF val["stringValue"] <> null THEN RETURN val["stringValue"];
    RETURN null;
END;

-- Save a preference to Firestore (fire-and-forget via PATCH_AUTH)
FIRESTORE_SAVE(key, value) := BEGIN
    IF _auth_uid = '' THEN RETURN null;
    IF NOT (key IN _FIRESTORE_SYNCED_KEYS) THEN RETURN null;
    __token := LOAD_STATE('_auth_id_token', '');
    IF __token = '' THEN RETURN null;
    __fields := {};
    __fields[key] := __TO_FIRESTORE_VALUE(value);
    __url := __FIRESTORE_DOC_URL() + '?updateMask.fieldPaths=' + key;
    __patch_body := {};
    __patch_body["fields"] := __fields;
    PATCH_AUTH(__url, __patch_body, __token);
END;

-- Load all synced preferences from Firestore
FIRESTORE_LOAD_ALL() := BEGIN
    IF _auth_uid = '' THEN RETURN {};
    __token := LOAD_STATE('_auth_id_token', '');
    IF __token = '' THEN RETURN {};
    __response := FETCH_AUTH(__FIRESTORE_DOC_URL(), __token);
    IF __response = null THEN RETURN {};
    __fields := __response["fields"];
    IF __fields = null THEN RETURN {};
    __result := {};
    FOR __i := 0 TO LENGTH(_FIRESTORE_SYNCED_KEYS) - 1 DO BEGIN
        __key := _FIRESTORE_SYNCED_KEYS[__i];
        __fval := __fields[__key];
        IF __fval <> null THEN
            __result[__key] := __FROM_FIRESTORE_VALUE(__fval);
    END;
    RETURN __result;
END;

-- Wrapper: save locally + sync to Firestore
SAVE_PREF(key, value) := BEGIN
    SAVE_STATE(key, value);
    FIRESTORE_SAVE(key, value);
END;

-- ============================================
-- Theme
-- ============================================
_is_dark_mode := LOAD_STATE('is_dark_mode', FALSE);

TOGGLE_DARK_MODE() := BEGIN
    _is_dark_mode := NOT _is_dark_mode;
    SAVE_PREF('is_dark_mode', _is_dark_mode);
    SET('_is_dark_mode', _is_dark_mode);
END;

SET_DARK_MODE(enabled) := BEGIN
    _is_dark_mode := enabled;
    SAVE_PREF('is_dark_mode', enabled);
    SET('_is_dark_mode', enabled);
END;

-- ============================================
-- Onboarding
-- ============================================
_analytics_enabled := LOAD_STATE('analytics_enabled', FALSE);
_crashlytics_enabled := LOAD_STATE('crashlytics_enabled', FALSE);
_location_enabled := LOAD_STATE('location_enabled', FALSE);
_onboarding_completed := LOAD_STATE('onboarding_completed', FALSE);

SET_ANALYTICS_CONSENT(enabled) := BEGIN
    _analytics_enabled := enabled;
    SAVE_PREF('analytics_enabled', enabled);
END;

SET_CRASHLYTICS_CONSENT(enabled) := BEGIN
    _crashlytics_enabled := enabled;
    SAVE_PREF('crashlytics_enabled', enabled);
END;

SET_LOCATION_CONSENT(enabled) := BEGIN
    _location_enabled := enabled;
    SAVE_PREF('location_enabled', enabled);
    SET('_location_enabled', enabled);
END;

COMPLETE_ONBOARDING() := BEGIN
    _onboarding_completed := TRUE;
    SAVE_PREF('onboarding_completed', TRUE);
END;

IS_ONBOARDING_COMPLETED() := _onboarding_completed;

RESET_ONBOARDING() := BEGIN
    _onboarding_completed := FALSE;
    SAVE_PREF('onboarding_completed', FALSE);
    GO_TO('onboarding');
END;

-- ============================================
-- API Configuration
-- ============================================
_api_key := LOAD_STATE('api_key', '');
_api_host := LOAD_STATE('api_host', 'www.superheroapi.com');

SET_API_KEY(key) := BEGIN
    _api_key := key;
    SAVE_PREF('api_key', key);
    SET('_api_key', key);
END;

SET_API_HOST(host) := BEGIN
    _api_host := host;
    SAVE_PREF('api_host', host);
    SET('_api_host', host);
END;

-- ============================================
-- Hero Statistics
-- ============================================
-- Running totals for O(1) avg/stdev derivation
_height_total := 0;
_height_sq_total := 0;
_height_count := 0;
_weight_total := 0;
_weight_sq_total := 0;
_weight_count := 0;

-- Running total: sum of strength across all heroes
_total_fighting_power := 0;

-- Derived statistics (recomputed from running totals via DERIVE_STATS)
_height_avg := 0;
_height_stdev := 0;
_weight_avg := 0;
_weight_stdev := 0;

-- Derive avg and stdev from running totals. O(1).
-- avg = total/count, stdev = sqrt(E[X²] - E[X]²)
-- No SET() needed — these are consumed within SHQL™; onMutated fires from eval().
DERIVE_STATS() := BEGIN
    _height_avg := IF _height_count = 0 THEN 0 ELSE _height_total / _height_count;
    __hvar := IF _height_count = 0 THEN 0 ELSE _height_sq_total / _height_count - _height_avg * _height_avg;
    _height_stdev := IF __hvar <= 0 THEN 0 ELSE POW(__hvar, 0.5);
    _weight_avg := IF _weight_count = 0 THEN 0 ELSE _weight_total / _weight_count;
    __wvar := IF _weight_count = 0 THEN 0 ELSE _weight_sq_total / _weight_count - _weight_avg * _weight_avg;
    _weight_stdev := IF __wvar <= 0 THEN 0 ELSE POW(__wvar, 0.5);
END;

-- Incremental: hero added to collection. O(1).
-- Null height/weight values are skipped (no contribution to totals).
STATS_HERO_ADDED(__hero) := BEGIN
    __ht := HEIGHT_M(__hero, null);
    IF __ht <> null THEN BEGIN
        _height_total := _height_total + __ht;
        _height_sq_total := _height_sq_total + __ht * __ht;
        _height_count := _height_count + 1;
    END;
    __wt := WEIGHT_KG(__hero, null);
    IF __wt <> null THEN BEGIN
        _weight_total := _weight_total + __wt;
        _weight_sq_total := _weight_sq_total + __wt * __wt;
        _weight_count := _weight_count + 1;
    END;
    _total_fighting_power := _total_fighting_power + POWERSTATS(__hero, p => p.strength, 0);
    DERIVE_STATS();
END;

-- Incremental: hero removed from collection. O(1).
-- Null height/weight values are skipped (they never contributed).
STATS_HERO_REMOVED(__hero) := BEGIN
    __ht := HEIGHT_M(__hero, null);
    IF __ht <> null THEN BEGIN
        _height_total := _height_total - __ht;
        _height_sq_total := _height_sq_total - __ht * __ht;
        _height_count := _height_count - 1;
    END;
    __wt := WEIGHT_KG(__hero, null);
    IF __wt <> null THEN BEGIN
        _weight_total := _weight_total - __wt;
        _weight_sq_total := _weight_sq_total - __wt * __wt;
        _weight_count := _weight_count - 1;
    END;
    _total_fighting_power := _total_fighting_power - POWERSTATS(__hero, p => p.strength, 0);
    DERIVE_STATS();
END;

-- Incremental: hero replaced (amend/update). O(1).
-- Either side's height/weight can be null (no-op for that dimension).
STATS_HERO_REPLACED(__old, __new) := BEGIN
    STATS_HERO_REMOVED(__old);
    STATS_HERO_ADDED(__new);
END;

-- Reset all running totals to zero. For clear-all-data.
STATS_CLEAR() := BEGIN
    _height_total := 0;
    _height_sq_total := 0;
    _height_count := 0;
    _weight_total := 0;
    _weight_sq_total := 0;
    _weight_count := 0;
    _total_fighting_power := 0;
    DERIVE_STATS();
END;

-- ============================================
-- Filters & Predicates
-- ============================================

-- Named filters (persisted). Each filter is OBJECT{name, predicate}.
-- Defaults: Heroes, Villains, Giants, Dwarves, Read Heads, Obsese, Strong Villains, Dumb Villains, Non-Males and Troglodytes.
-- Use RESET_PREDICATES() to restore them.
-- "Giants" anmd "Dwarves" demonstrate computed predicates (height > avg + 2*stdev and height < avg-2*stdev, respectively)
_DEFAULT_FILTERS := [
    OBJECT{name: "Heroes", predicate: "biography.alignment <= good"},
    OBJECT{name: "Villains", predicate: "biography.alignment > good"},
    OBJECT{name: "Giants", predicate: "appearance.height.m > _height_avg + 2 * _height_stdev"},
    OBJECT{name: "Dwarves", predicate: "appearance.height.m < _height_avg - 2 * _height_stdev"},
    OBJECT{name: "Red Heads", predicate: 'appearance.hair_colour ~ "red"'},
    OBJECT{name: "Obese", predicate: "appearance.weight.kg / POW(appearance.height.m, 2) >= 30"},
    OBJECT{name: "Strong Villains", predicate: "biography.alignment > reasonable AND powerstats.strength >= powerstats.intelligence*1.1"},
    OBJECT{name: "Dumb Villains", predicate: "biography.alignment >= bad AND powerstats.intelligence <= 50"},
    OBJECT{name: "Non-Males", predicate: "appearance.gender <> male"},
    OBJECT{name: "Troglodytes", predicate: 'work.base ~ "cave"'}
];
_filters := LOAD_STATE('filters', _DEFAULT_FILTERS);
_filter_counts := [];
_filtered_heroes := [];
_filter_lambdas := {};
_active_filter_index := -1;
_displayed_heroes := [];
_current_query := '';

-- Rebuild all filter result maps from scratch. Called after filter CRUD
-- or batch operations (reconcile, init). Each _filtered_heroes[i] is a
-- map keyed by hero ID for O(1) add/remove.
-- Apply a predicate to a hero list, returning a map of matching heroes keyed by ID.
-- Single place for predicate-based filtering — used by REBUILD_ALL_FILTERS,
-- ON_HERO_ADDED, and FILTER_DISPLAYED.
-- Calls predicate lambdas directly in SHQL™ (no Dart roundtrip).
-- Falls back to text-match via MATCH() when pred is null.
APPLY_PREDICATE(__hero_list, __pred, __predText) := BEGIN
    __result := {};
    IF LENGTH(__hero_list) > 0 THEN
        FOR __j := 0 TO LENGTH(__hero_list) - 1 DO BEGIN
            __hero := __hero_list[__j];
            __match := IF __pred <> null THEN __pred(__hero) ELSE MATCH(__hero, __predText);
            IF __match THEN
                __result[__hero.ID] := __hero;
        END;
    RETURN __result;
END;

REBUILD_ALL_FILTERS() := BEGIN
    __hero_list := MAP_VALUES(_heroes);
    _filtered_heroes := [];
    _filter_counts := [];
    DEBUG_LOG('[REBUILD] start: ' + STRING(LENGTH(_filters)) + ' filters, ' + STRING(LENGTH(__hero_list)) + ' heroes');
    FOR __i := 0 TO LENGTH(_filters) - 1 DO BEGIN
        __predText := _filters[__i].PREDICATE;
        __fname := _filters[__i].NAME;
        __pred := IF __predText = '' OR __predText = null THEN null ELSE _filter_lambdas[__fname];
        DEBUG_LOG('[REBUILD]   [' + STRING(__i) + '] name="' + __fname + '" pred=' + IF __pred <> null THEN 'lambda' ELSE 'NULL' + ' predText="' + __predText + '"');
        __result := APPLY_PREDICATE(__hero_list, __pred, __predText);
        _filtered_heroes := _filtered_heroes + [__result];
        _filter_counts := _filter_counts + [LENGTH(__result)];
        DEBUG_LOG('[REBUILD]   [' + STRING(__i) + '] name="' + __fname + '" count=' + STRING(LENGTH(__result)));
    END;
    SET('_filter_counts', _filter_counts);
    DEBUG_LOG('[REBUILD] done: counts=' + STRING(_filter_counts));
END;

-- Update _displayed_heroes from the active filter or full hero map.
-- Always produces a list (via MAP_VALUES) for card generation.
UPDATE_DISPLAYED_HEROES() := BEGIN
    IF _active_filter_index < 0 OR _active_filter_index >= LENGTH(_filtered_heroes) THEN
        _displayed_heroes := MAP_VALUES(_heroes)
    ELSE
        _displayed_heroes := MAP_VALUES(_filtered_heroes[_active_filter_index]);
    SET('_displayed_heroes', _displayed_heroes);
END;

-- Filter _heroes by a compiled predicate and update _displayed_heroes.
-- Called from Dart after compiling a text query or SHQL™ expression.
FILTER_DISPLAYED(__pred, __predText) := BEGIN
    __matched := APPLY_PREDICATE(MAP_VALUES(_heroes), __pred, __predText);
    _displayed_heroes := MAP_VALUES(__matched);
    SET('_displayed_heroes', _displayed_heroes);
END;

-- Apply a filter by index (-1 = All, 0+ = index into filter arrays).
-- Clears any active text query (filters and text queries are mutually exclusive).
APPLY_FILTER(index) := BEGIN
    _active_filter_index := index;
    _current_query := '';
    SET('_active_filter_index', _active_filter_index);
    SET('_current_query', _current_query);
    UPDATE_DISPLAYED_HEROES();
END;

-- Save or update a named filter. If name exists, updates its predicate in place.
SAVE_FILTER(name, predicate) := BEGIN
    new_filters := [];
    found := FALSE;
    FOR i := 0 TO LENGTH(_filters) - 1 DO BEGIN
        IF _filters[i].name = name THEN BEGIN
            new_filters := new_filters + [OBJECT{name: name, predicate: predicate}];
            found := TRUE;
        END ELSE
            new_filters := new_filters + [_filters[i]];
    END;
    _filters := IF found THEN new_filters ELSE _filters + [OBJECT{name: name, predicate: predicate}];
    SAVE_PREF('filters', _filters);
    SET('_filters', _filters);
END;

-- Delete any filter by index. All filters are user-defined and deletable.
-- Use RESET_PREDICATES() to restore the defaults.
DELETE_FILTER(index) := BEGIN
    IF index < 0 OR index >= LENGTH(_filters) THEN RETURN;
    new_filters := [];
    FOR i := 0 TO LENGTH(_filters) - 1 DO
        IF i <> index THEN
            new_filters := new_filters + [_filters[i]];
    _filters := new_filters;
    SAVE_PREF('filters', _filters);
    SET('_filters', _filters);
    IF _active_filter_index >= LENGTH(_filters) OR _active_filter_index = index THEN
        APPLY_FILTER(-1);
END;

-- Reset to the three default filters. Replaces the entire list.
RESET_PREDICATES() := BEGIN
    _filters := _DEFAULT_FILTERS;
    SAVE_PREF('filters', _filters);
    SET('_filters', _filters);
    APPLY_FILTER(-1);
END;

-- Add a new empty filter and select it for editing
ADD_FILTER() := BEGIN
    SAVE_FILTER('New Filter', '');
    APPLY_FILTER(LENGTH(_filters) - 1);
END;

-- Rename a filter by index
RENAME_FILTER(index, new_name) := BEGIN
    IF index < 0 OR index >= LENGTH(_filters) THEN RETURN;
    old := _filters[index];
    new_filters := [];
    FOR i := 0 TO LENGTH(_filters) - 1 DO
        IF i = index THEN
            new_filters := new_filters + [OBJECT{name: new_name, predicate: old.predicate}]
        ELSE
            new_filters := new_filters + [_filters[i]];
    _filters := new_filters;
    SAVE_PREF('filters', _filters);
    SET('_filters', _filters);
END;

-- Apply an ad-hoc query without saving it as a named filter
APPLY_QUERY(expression) := BEGIN
    _current_query := expression;
    _active_filter_index := -1;
    SET('_current_query', _current_query);
    SET('_active_filter_index', _active_filter_index);
END;

-- _filter_counts[i] corresponds to _filters[i] (set by REBUILD_ALL_FILTERS).
GET_FILTER_COUNT(index) := IF index < 0 OR index >= LENGTH(_filter_counts) THEN 0 ELSE _filter_counts[index];

-- Generate filter list items for home screen (one per named filter)
GENERATE_FILTER_COUNTER_CARDS() := BEGIN
    result := [];
    _icons := ['shield', 'dangerous'];
    _colors := ['0xFF2196F3', '0xFFF44336'];

    FOR i := 0 TO LENGTH(_filters) - 1 DO BEGIN
        count := IF i < LENGTH(_filter_counts) THEN _filter_counts[i] ELSE 0;
        icon := IF i < LENGTH(_icons) THEN _icons[i] ELSE 'label';
        color := IF i < LENGTH(_colors) THEN _colors[i] ELSE '0xFF9E9E9E';
        name := _filters[i].name;

        item := {
            "type": "Card",
            "props": {
                "onTap": "shql: APPLY_FILTER(" + STRING(i) + "); GO_TO('heroes')",
                "child": {
                    "type": "Padding",
                    "props": {
                        "padding": 8,
                        "child": {
                            "type": "Row",
                            "props": {
                                "children": [
                                    {"type": "Icon", "props": {"icon": icon, "color": color, "size": 20}},
                                    {"type": "SizedBox", "props": {"width": 12}},
                                    {"type": "Expanded", "child": {"type": "Text", "props": {"data": name}}},
                                    {"type": "Text", "props": {"data": STRING(count), "style": {"fontWeight": "bold", "fontSize": 16}}}
                                ]
                            }
                        }
                    }
                }
            }
        };
        result := result + [item];
    END;
    RETURN result;
END;

-- ============================================
-- Hero Collection
-- ============================================
_heroes := {};
_selected_hero := null;
_hero_cards := [];
_is_loading := FALSE;
_error_message := '';
_total_heroes := 0;
_reconcile_active := FALSE;
_reconcile_aborted := FALSE;
_reconcile_current := '';
_reconcile_status := '';
_reconcile_log := [];

-- Abort an in-progress reconciliation (checked each iteration by Dart)
ABORT_RECONCILE() := BEGIN
    _reconcile_aborted := TRUE;
    SET('_reconcile_aborted', _reconcile_aborted);
END;

-- Notify YAML Observers that watch hero/filter/stats variables.
-- Observer uses addListener, so SET() is required for UI updates.
_NOTIFY_HERO_STATE() := BEGIN
    SET('_heroes', _heroes);
    SET('_total_heroes', _total_heroes);
    SET('_total_fighting_power', _total_fighting_power);
    SET('_filter_counts', _filter_counts);
END;

-- Hero added to collection. Updates heroes map, running stats, and filter
-- membership in one call. O(filters).
-- During init _filtered_heroes is [] so the filter block is guarded.
ON_HERO_ADDED(__hero) := BEGIN
    _heroes[__hero.ID] := __hero;
    _total_heroes := LENGTH(_heroes);
    STATS_HERO_ADDED(__hero);
    IF LENGTH(_filtered_heroes) > 0 THEN
        FOR __i := 0 TO LENGTH(_filtered_heroes) - 1 DO BEGIN
            __predText := _filters[__i].PREDICATE;
            __fname := _filters[__i].NAME;
            IF __predText = '' OR __predText = null THEN
                _filtered_heroes[__i][__hero.ID] := __hero
            ELSE BEGIN
                __pred := _filter_lambdas[__fname];
                __match := IF __pred <> null THEN __pred(__hero) ELSE MATCH(__hero, __predText);
                IF __match THEN
                    _filtered_heroes[__i][__hero.ID] := __hero;
            END;
            _filter_counts[__i] := LENGTH(_filtered_heroes[__i]);
            DEBUG_LOG('[ON_HERO_ADDED] [' + STRING(__i) + '] "' + __fname + '" count=' + STRING(_filter_counts[__i]));
        END;
    _NOTIFY_HERO_STATE();
END;

-- Hero removed from collection. O(filters).
ON_HERO_REMOVED(__hero) := BEGIN
    MAP_REMOVE(_heroes, __hero.ID);
    _total_heroes := LENGTH(_heroes);
    STATS_HERO_REMOVED(__hero);
    IF LENGTH(_filtered_heroes) > 0 THEN
        FOR __i := 0 TO LENGTH(_filtered_heroes) - 1 DO BEGIN
            MAP_REMOVE(_filtered_heroes[__i], __hero.ID);
            _filter_counts[__i] := LENGTH(_filtered_heroes[__i]);
        END;
    _NOTIFY_HERO_STATE();
END;

-- Hero replaced (amend/update). Removes old, adds new. O(filters).
-- ON_HERO_REMOVED + ON_HERO_ADDED each notify; harmless double-notify.
ON_HERO_REPLACED(__old, __new) := BEGIN
    ON_HERO_REMOVED(__old);
    ON_HERO_ADDED(__new);
END;

-- Clear all heroes. Resets heroes map, stats, and all filter result maps.
ON_HERO_CLEAR() := BEGIN
    _heroes := {};
    _total_heroes := 0;
    STATS_CLEAR();
    IF LENGTH(_filtered_heroes) > 0 THEN
        FOR __i := 0 TO LENGTH(_filtered_heroes) - 1 DO BEGIN
            _filtered_heroes[__i] := {};
            _filter_counts[__i] := 0;
        END;
    _NOTIFY_HERO_STATE();
END;

-- Select a hero for detail view
SELECT_HERO(hero) := BEGIN
    _selected_hero := hero;
    SET('_selected_hero', hero);
    GO_TO('hero_detail');
END;

-- Save a hero to local database (extracts external_id from SHQL™ object)
SAVE_HERO(hero) := BEGIN
    _PERSIST_HERO(hero.external_id);
END;

-- Nullary function SHQL™ wrappers.
-- Native nullary functions are registered as _CLEAR_ALL_DATA, _RECONCILE_HEROES.
-- We wrap them so SHQL™ can call them with FOO() syntax (the parser always
-- creates call(identifier, tuple) for FOO(), but IdentifierExecutionNode
-- correctly executes nullary functions when referenced WITHOUT parentheses).
CLEAR_ALL_DATA() := _CLEAR_ALL_DATA;
RECONCILE_HEROES() := _RECONCILE_HEROES;
SIGN_OUT() := BEGIN
    FIREBASE_SIGN_OUT();
    _SIGN_OUT;
END;

-- Toggle hero lock state (lock/unlock for reconciliation)
-- (native implementation in Dart via _TOGGLE_LOCK_HERO unary function)

GET_HERO_COUNT() := LENGTH(_heroes);

-- ============================================
-- Hero Detail Helpers (used by GENERATE_HERO_DETAIL)
-- ============================================

-- Wrap children in a Card with a section title, with padding.
_MAKE_DETAIL_CARD(section_title, children) := {
    "type": "Padding",
    "props": {
        "padding": {"left": 16, "right": 16, "bottom": 16},
        "child": {
            "type": "Card",
            "props": {
                "child": {
                    "type": "Padding",
                    "props": {
                        "padding": 16,
                        "child": {
                            "type": "Column",
                            "props": {
                                "crossAxisAlignment": "start",
                                "children": [{"type": "Text", "props": {"data": section_title, "style": {"fontSize": 18, "fontWeight": "bold"}}}, {"type": "SizedBox", "props": {"height": 12}}] + children
                            }
                        }
                    }
                }
            }
        }
    }
};

-- A single stat widget: big colored number with label
_MAKE_STAT_WIDGET(fld, hero) := {
    "type": "Expanded",
    "child": {
        "type": "Column",
        "children": [
            {"type": "Text", "props": {"data": fld.LABEL, "style": {"fontSize": 12, "color": "0xFF757575"}}},
            {"type": "Text", "props": {"data": (IF hero <> null THEN STRING(fld.ACCESSOR(hero)) ELSE '-'), "style": {"fontSize": 24, "fontWeight": "bold", "color": fld.COLOR}}}
        ]
    }
};

-- A label:value text row
_MAKE_TEXT_ROW(fld, hero) := [
    {"type": "Row", "children": [
        {"type": "Text", "props": {"data": fld.LABEL + ": ", "style": {"fontWeight": "bold"}}},
        {"type": "Expanded", "child": {"type": "Text", "props": {"data": (IF hero <> null THEN STRING(fld.ACCESSOR(hero)) ELSE 'Unknown')}}}
    ]},
    {"type": "SizedBox", "props": {"height": 8}}
];

-- An enum label:value row (uses a label list for display)
_MAKE_ENUM_ROW(fld, hero) := [
    {"type": "Row", "children": [
        {"type": "Text", "props": {"data": fld.LABEL + ": ", "style": {"fontWeight": "bold"}}},
        {"type": "Expanded", "child": {"type": "Text", "props": {"data": (IF hero <> null THEN fld.ENUM_LABELS[fld.ACCESSOR(hero)] ELSE 'Unknown')}}}
    ]},
    {"type": "SizedBox", "props": {"height": 8}}
];

-- A measurement label:value row (height/weight with unit suffix and > 0 check)
_MAKE_MEASUREMENT_ROW(fld, hero) := [
    {"type": "Row", "children": [
        {"type": "Text", "props": {"data": fld.LABEL + ": ", "style": {"fontWeight": "bold"}}},
        {"type": "Expanded", "child": {"type": "Text", "props": {"data": (IF hero <> null AND fld.ACCESSOR(hero) > 0 THEN STRING(fld.ACCESSOR(hero)) + ' ' + fld.UNIT ELSE 'Unknown')}}}
    ]},
    {"type": "SizedBox", "props": {"height": 8}}
];

-- ============================================
-- GENERATE_HERO_DETAIL: data-driven detail view
-- ============================================
-- Iterates _detail_fields metadata and builds the full detail body widget tree.
-- Hero image & alignment badge at top, then one Card per section.
GENERATE_HERO_DETAIL() := BEGIN
    hero := _selected_hero;
    IF hero = null THEN RETURN {"type": "SizedBox"};

    result := [];

    -- Hero Image
    __img_url := IMAGE(hero, img => img.url, null);
    __img_widget := IF __img_url <> null THEN
        {"type": "Image", "props": {"src": __img_url, "fit": "contain"}}
    ELSE
        {"type": "Icon", "props": {"icon": "person", "size": 100, "color": "0xFF757575"}};
    result := result + [{"type": "Container", "props": {"height": 300, "color": "0xFF212121", "child": __img_widget}}];

    -- Alignment Badge
    __align := BIOGRAPHY(hero, b => b.alignment, 0);
    __badge_color := IF __align <= GOOD THEN '0xFF2196F3' ELSE IF __align >= BAD THEN '0xFFF44336' ELSE '0xFF9E9E9E';
    __badge_text := UPPERCASE(_ALIGNMENT_LABELS[__align]);
    result := result + [{
        "type": "Container",
        "props": {
            "transform": "translate(0, -20)",
            "alignment": "center",
            "child": {
                "type": "Container",
                "props": {
                    "padding": {"horizontal": 24, "vertical": 8},
                    "decoration": {"color": __badge_color, "borderRadius": 20},
                    "child": {"type": "Text", "props": {"data": __badge_text, "style": {"color": "0xFFFFFFFF", "fontWeight": "bold"}}}
                }
            }
        }
    }];

    -- Iterate _detail_fields grouped by section
    current_section := '';
    section_children := [];
    stat_widgets := [];

    FOR __i := 0 TO LENGTH(_detail_fields) - 1 DO BEGIN
        fld := _detail_fields[__i];

        -- When section changes, flush the previous section
        IF fld.SECTION <> current_section THEN BEGIN
            IF current_section <> '' THEN BEGIN
                -- If the previous section had stats, lay them out in rows of 3
                IF LENGTH(stat_widgets) > 0 THEN BEGIN
                    section_children := [{"type": "SizedBox", "props": {"height": 4}}];
                    __row := [];
                    FOR __s := 0 TO LENGTH(stat_widgets) - 1 DO BEGIN
                        __row := __row + [stat_widgets[__s]];
                        IF LENGTH(__row) = 3 OR __s = LENGTH(stat_widgets) - 1 THEN BEGIN
                            section_children := section_children + [{"type": "Row", "children": __row}];
                            IF __s < LENGTH(stat_widgets) - 1 THEN
                                section_children := section_children + [{"type": "SizedBox", "props": {"height": 16}}];
                            __row := [];
                        END;
                    END;
                END;
                result := result + [_MAKE_DETAIL_CARD(current_section, section_children)];
            END;
            current_section := fld.SECTION;
            section_children := [];
            stat_widgets := [];
        END;

        -- Build widget based on display_type
        IF fld.DISPLAY_TYPE = 'stat' THEN
            stat_widgets := stat_widgets + [_MAKE_STAT_WIDGET(fld, hero)]
        ELSE IF fld.DISPLAY_TYPE = 'enum_label' THEN
            section_children := section_children + _MAKE_ENUM_ROW(fld, hero)
        ELSE IF fld.DISPLAY_TYPE = 'measurement' THEN
            section_children := section_children + _MAKE_MEASUREMENT_ROW(fld, hero)
        ELSE
            section_children := section_children + _MAKE_TEXT_ROW(fld, hero);
    END;

    -- Flush last section
    IF current_section <> '' THEN BEGIN
        IF LENGTH(stat_widgets) > 0 THEN BEGIN
            section_children := [{"type": "SizedBox", "props": {"height": 4}}];
            __row := [];
            FOR __s := 0 TO LENGTH(stat_widgets) - 1 DO BEGIN
                __row := __row + [stat_widgets[__s]];
                IF LENGTH(__row) = 3 OR __s = LENGTH(stat_widgets) - 1 THEN BEGIN
                    section_children := section_children + [{"type": "Row", "children": __row}];
                    IF __s < LENGTH(stat_widgets) - 1 THEN
                        section_children := section_children + [{"type": "SizedBox", "props": {"height": 16}}];
                    __row := [];
                END;
            END;
        END;
        result := result + [_MAKE_DETAIL_CARD(current_section, section_children)];
    END;

    result := result + [{"type": "SizedBox", "props": {"height": 24}}];

    RETURN {"type": "SingleChildScrollView", "props": {"child": {"type": "Column", "props": {"crossAxisAlignment": "stretch", "children": result}}}};
END;

-- ============================================
-- Hero Card Generation (data-driven from _summary_fields)
-- ============================================

-- Alignment visual metadata (indexed by ordinal 0-9)
_ALIGNMENT_COLORS := ['0xFF9E9E9E', '0xFF78909C', '0xFF29B6F6', '0xFF42A5F5', '0xFF7986CB', '0xFFFFA726', '0xFFE53935', '0xFFC62828', '0xFF8B0000', '0xFF0D0000'];
_ALIGNMENT_BORDER_COLORS := ['0x809E9E9E', '0x8078909C', '0x8029B6F6', '0x8042A5F5', '0x807986CB', '0x80FFA726', '0x80E53935', '0x80C62828', '0x808B0000', '0x800D0000'];
_ALIGNMENT_ICONS := ['help_outline', 'balance', 'verified_user', 'shield', 'thumb_up', 'warning_amber', 'whatshot', 'mood_bad', 'local_fire_department', 'volume_up'];
_ALIGNMENT_GRADIENT_START := ['0xFF9E9E9E', '0xFF78909C', '0xFF29B6F6', '0xFF42A5F5', '0xFF7986CB', '0xFFFFA726', '0xFFE53935', '0xFFC62828', '0xFF8B0000', '0xFF0D0000'];
_ALIGNMENT_GRADIENT_END := ['0xFF616161', '0xFF455A64', '0xFF1E88E5', '0xFF00897B', '0xFF3949AB', '0xFFE64A19', '0xFF4A0000', '0xFF3A0000', '0xFF1A0000', '0xFF000000'];

-- Safe alignment index (clamp to valid range)
_ALIGN_IDX(__a) := IF __a < 0 OR __a >= LENGTH(_ALIGNMENT_COLORS) THEN 0 ELSE __a;

-- Subtitle: publisher + race joined by bullet
_HERO_SUBTITLE(__publisher, __race) := BEGIN
    __has_pub := __publisher <> null AND __publisher <> '';
    __has_race := __race <> null AND __race <> '';
    RETURN IF __has_pub AND __has_race THEN __publisher + ' \u2022 ' + __race
           ELSE IF __has_pub THEN __publisher
           ELSE IF __has_race THEN __race
           ELSE '';
END;

-- Semantics label for accessibility
_HERO_SEMANTICS(__name, __align_label, __stats) := BEGIN
    __label := __name + ', ' + __align_label + ' alignment';
    IF LENGTH(__stats) > 0 THEN
        FOR __k := 0 TO LENGTH(__stats) - 1 DO
            __label := __label + ', ' + __stats[__k].LABEL + ' ' + STRING(__stats[__k].VALUE);
    RETURN __label;
END;

-- Build stat chip rows (groups of 3 with gaps)
_MAKE_STAT_CHIP_ROWS(__stats) := BEGIN
    __rows := [];
    IF LENGTH(__stats) = 0 THEN RETURN __rows;
    __row_children := [];
    FOR __k := 0 TO LENGTH(__stats) - 1 DO BEGIN
        IF LENGTH(__row_children) > 0 THEN
            __row_children := __row_children + [{"type": "SizedBox", "props": {"width": 4}}];
        __row_children := __row_children + [{"type": "StatChip", "props": {
            "label": __stats[__k].LABEL,
            "valueText": STRING(__stats[__k].VALUE),
            "color": __stats[__k].COLOR,
            "bgColor": __stats[__k].BG_COLOR
        }}];
        IF LENGTH(__row_children) >= 5 OR __k = LENGTH(__stats) - 1 THEN BEGIN
            -- 5 children = 3 chips + 2 gaps (groups of 3 chips)
            IF LENGTH(__rows) > 0 THEN
                __rows := __rows + [{"type": "SizedBox", "props": {"height": 4}}];
            __rows := __rows + [{"type": "Row", "children": __row_children}];
            __row_children := [];
        END;
    END;
    RETURN __rows;
END;

-- Build a complete hero card widget tree.
-- All JSON structure generation happens here in SHQL™ — no Dart factory needed.
_MAKE_HERO_CARD_TREE(__hero, __onTap, __onDelete, __locked, __onToggleLock) := BEGIN
    -- Collect props from _summary_fields
    __stats := [];
    __name := '';
    __publisher := '';
    __race := '';
    __alignment := 0;
    __totalPower := 0;
    __url := null;

    FOR __j := 0 TO LENGTH(_summary_fields) - 1 DO BEGIN
        __sf := _summary_fields[__j];
        IF __sf.IS_STAT THEN
            __stats := __stats + [OBJECT{value: __sf.ACCESSOR(__hero), label: __sf.LABEL, color: __sf.COLOR, bg_color: __sf.BG_COLOR}]
        ELSE BEGIN
            __val := __sf.ACCESSOR(__hero);
            IF __sf.PROP_NAME = 'name' THEN __name := __val
            ELSE IF __sf.PROP_NAME = 'publisher' THEN __publisher := __val
            ELSE IF __sf.PROP_NAME = 'race' THEN __race := __val
            ELSE IF __sf.PROP_NAME = 'alignment' THEN __alignment := __val
            ELSE IF __sf.PROP_NAME = 'totalPower' THEN __totalPower := __val
            ELSE IF __sf.PROP_NAME = 'url' THEN __url := __val;
        END;
    END;

    __ai := _ALIGN_IDX(__alignment);
    __align_color := _ALIGNMENT_COLORS[__ai];
    __align_border := _ALIGNMENT_BORDER_COLORS[__ai];
    __align_icon := _ALIGNMENT_ICONS[__ai];
    __align_label := _ALIGNMENT_LABELS[__alignment];
    __subtitle := _HERO_SUBTITLE(__publisher, __race);

    -- Stat chip rows
    __stat_rows := _MAKE_STAT_CHIP_ROWS(__stats);

    -- Info children (name, subtitle, stats, power bar)
    __info := [{"type": "Text", "props": {"data": __name, "style": {"fontWeight": "bold"}}}];

    IF __subtitle <> '' THEN
        __info := __info + [
            {"type": "SizedBox", "props": {"height": 2}},
            {"type": "Text", "props": {"data": __subtitle, "style": {"fontSize": 12, "color": IF _is_dark_mode THEN '0xFF9E9E9E' ELSE '0xFF757575'}}}
        ];

    IF LENGTH(__stat_rows) > 0 THEN
        __info := __info + [{"type": "SizedBox", "props": {"height": 8}}] + __stat_rows;

    IF __totalPower <> null AND __totalPower > 0 THEN BEGIN
        __progress := __totalPower / 600;
        IF __progress > 1 THEN __progress := 1;
        __info := __info + [
            {"type": "SizedBox", "props": {"height": 8}},
            {"type": "PowerBar", "props": {
                "label": "Total Power: " + STRING(__totalPower),
                "progress": __progress,
                "color": __align_color,
                "bgColor": IF _is_dark_mode THEN '0xFF616161' ELSE '0xFFE0E0E0'
            }}
        ];
    END;

    -- Build the image section: Expanded > Stack > [CachedImage, badge, overlays]
    __ph_color := IF _is_dark_mode THEN '0xFF424242' ELSE '0xFFEEEEEE';
    __ph_icon_color := IF _is_dark_mode THEN '0xFF757575' ELSE '0xFFBDBDBD';

    __placeholder := {"type": "Container", "props": {"color": __ph_color, "child": {"type": "HeroPlaceholder", "props": {"color": __ph_icon_color}}}};
    __spinner := {"type": "Container", "props": {"color": __ph_color, "child": {"type": "Center", "props": {"child": {"type": "CircularProgressIndicator", "props": {}}}}}};

    -- CachedImage is the ONLY Dart boundary (3rd-party with builder callbacks)
    __stack_children := [{"type": "CachedImage", "props": {"imageUrl": __url, "placeholder": __placeholder, "spinner": __spinner}}];

    -- Alignment badge — Container with gradient (now supported in framework)
    __stack_children := __stack_children + [{"type": "Positioned", "props": {
        "top": 8, "left": 8,
        "child": {"type": "Container", "props": {
            "padding": {"left": 8, "right": 8, "top": 4, "bottom": 4},
            "decoration": {"gradient": {"colors": [_ALIGNMENT_GRADIENT_START[__ai], _ALIGNMENT_GRADIENT_END[__ai]]}, "borderRadius": 12},
            "child": {"type": "BadgeRow", "props": {"icon": __align_icon, "label": __align_label}}
        }}
    }}];

    -- Overlay buttons (delete, lock)
    IF __onDelete <> null THEN
        __stack_children := __stack_children + [{"type": "OverlayActionButton", "props": {
            "top": 8, "right": 8,
            "label": "Remove " + __name + " from database",
            "bgColor": "0x8A000000",
            "onTap": __onDelete,
            "icon": "delete",
            "iconColor": "0xFFEF9A9A"
        }}];
    IF __onToggleLock <> null THEN
        __stack_children := __stack_children + [{"type": "OverlayActionButton", "props": {
            "top": IF __onDelete <> null THEN 48 ELSE 8, "right": 8,
            "label": IF __locked THEN "Unlock " + __name + " (currently locked from reconciliation)" ELSE "Lock " + __name + " (prevent reconciliation changes)",
            "bgColor": IF __locked THEN "0xE6FFA000" ELSE "0x8A000000",
            "onTap": __onToggleLock,
            "icon": IF __locked THEN "lock" ELSE "lock_open",
            "iconColor": "0xFFFFFFFF"
        }}];

    __image_section := {"type": "Expanded", "props": {"child": {"type": "Stack", "props": {"fit": "expand", "children": __stack_children}}}};

    -- Assemble card body
    __card := {"type": "HeroCardBody", "props": {
        "semanticsLabel": _HERO_SEMANTICS(__name, __align_label, __stats),
        "isButton": __onTap <> null,
        "borderColor": __align_border,
        "onTap": __onTap,
        "children": [
            __image_section,
            {"type": "Padding", "props": {
                "padding": 12,
                "child": {"type": "Column", "props": {
                    "crossAxisAlignment": "start",
                    "children": __info
                }}
            }}
        ]
    }};

    -- Wrap in DismissibleCard for swipe-to-delete
    IF __onDelete <> null THEN
        __card := {"type": "DismissibleCard", "props": {"onDismissed": __onDelete, "child": __card}};

    RETURN __card;
END;

-- source: the SHQL™ variable name as a string, e.g. '_heroes' or '_search_results'
-- deletable: TRUE for saved heroes (show trash can), FALSE for search results
GENERATE_HERO_CARDS(heroes, source, deletable) := BEGIN
    result := [];
    IF LENGTH(heroes) = 0 THEN
        RETURN result;

    FOR i := 0 TO LENGTH(heroes) - 1 DO BEGIN
        hero := heroes[i];
        __onTap := "SELECT_HERO(" + source + "[" + STRING(i) + "])";
        __onDelete := IF deletable THEN "DELETE_HERO('" + hero.id + "')" ELSE null;
        result := result + [_MAKE_HERO_CARD_TREE(hero, __onTap, __onDelete, FALSE, null)];
    END;
    RETURN result;
END;

-- Generate saved heroes list (uses _displayed_heroes which is filtered by active filter)
GENERATE_SAVED_HEROES_CARDS() := BEGIN
    IF LENGTH(_heroes) = 0 THEN
        RETURN [{
            "type": "Center",
            "child": {
                "type": "Column",
                "props": {
                    "mainAxisAlignment": "center",
                    "children": [
                        {"type": "Icon", "props": {"icon": "bookmark_border", "size": 64, "color": "0xFF9E9E9E"}},
                        {"type": "SizedBox", "props": {"height": 16}},
                        {"type": "Text", "props": {"data": "No heroes saved yet", "style": {"fontSize": 18}}},
                        {"type": "SizedBox", "props": {"height": 8}},
                        {"type": "Text", "props": {"data": "Search and save heroes to build your database!", "style": {"color": "0xFF9E9E9E"}}}
                    ]
                }
            }
        }];

    -- If filter/query is active but no heroes match, show an appropriate message
    IF LENGTH(_displayed_heroes) = 0 AND (_active_filter_index >= 0 OR NOT (IS_NULL_OR_WHITESPACE(_current_query))) THEN BEGIN
        __empty_msg := IF NOT (IS_NULL_OR_WHITESPACE(_current_query)) THEN 'No heroes match "' + _current_query + '"' ELSE 'No heroes match this filter';
        RETURN [{"type": "Center", "child": {"type": "Text", "props": {"data": __empty_msg, "style": {"fontSize": 16, "color": "0xFF757575"}}}}];
    END;

    RETURN GENERATE_HERO_CARDS(_displayed_heroes, '_displayed_heroes', TRUE);
END;

-- Generate a single saved hero card (used by Dart per-ID cache).
-- Uses ID-based lookup from _heroes so no display index is needed.
GENERATE_SINGLE_HERO_CARD(__hero) := BEGIN
    __onTap := "SELECT_HERO(_heroes['" + __hero.ID + "'])";
    __onDelete := "DELETE_HERO('" + __hero.ID + "')";
    __onToggleLock := "_TOGGLE_LOCK_HERO('" + __hero.ID + "')";
    RETURN _MAKE_HERO_CARD_TREE(__hero, __onTap, __onDelete, __hero.LOCKED, __onToggleLock);
END;

-- ============================================
-- Hero Search
-- ============================================
_search_results := [];
_search_query := '';
_search_history := LOAD_STATE('search_history', []);
-- Search summary (set by Dart after dialog-based save flow)
_search_summary := '';

-- Search for heroes via API
SEARCH_HEROES(query) := BEGIN
    IF LENGTH(query) < 2 THEN BEGIN
        _search_results := [];
        SET('_search_results', []);
        RETURN [];
    END;

    _search_query := query;
    _is_loading := TRUE;
    SET('_is_loading', TRUE);

    -- Add to search history
    IF NOT (query IN _search_history) THEN BEGIN
        _search_history := [query] + SLICE(_search_history, 0, 9);
        SAVE_STATE('search_history', _search_history);
    END;

    -- Call native Dart function to perform the actual API fetch
    _FETCH_HEROES(query);

    RETURN _search_query;
END;

-- Clear search results
CLEAR_SEARCH() := BEGIN
    _search_results := [];
    _search_query := '';
    SET('_search_results', []);
    SET('_search_query', '');
END;

-- Generate search result cards
GENERATE_SEARCH_CARDS() := BEGIN
    IF LENGTH(_search_results) = 0 THEN
        RETURN [{
            "type": "Center",
            "child": {
                "type": "Text",
                "props": {
                    "data": "No results found"
                }
            }
        }];

    RETURN GENERATE_HERO_CARDS(_search_results, '_search_results', FALSE);
END;

-- Generate search history chips
GENERATE_SEARCH_HISTORY() := BEGIN
    result := [];
    IF LENGTH(_search_history) = 0 THEN
        RETURN result;

    FOR i := 0 TO LENGTH(_search_history) - 1 DO BEGIN
        query := _search_history[i];
        result := result + [{
            "type": "ActionChip",
            "props": {
                "label": query,
                "onPressed": "shql: SEARCH_HEROES('" + query + "')"
            }
        }];
    END;
    RETURN result;
END;

-- ============================================
-- Hero Edit
-- ============================================
-- Edit hero form state (list of field descriptors, populated by _PREPARE_EDIT Dart callback)
_edit_fields := [];

-- Prepare edit form generically from the hero's Field hierarchy (Dart walks the tree)
-- and navigate to the edit screen.
EDIT_HERO() := BEGIN
    _PREPARE_EDIT;
    GO_TO('hero_edit');
END;

-- Submit amendments to native code
SAVE_AMENDMENTS() := BEGIN
    _APPLY_AMENDMENT(_selected_hero.id);
END;

-- Generate the edit form dynamically from _edit_fields (set by _PREPARE_EDIT).
-- Each field descriptor is OBJECT{section, label, json_section, json_name,
-- field_type ("string"|"enum"|"number"), value, original, options (list for enums)}.
-- Groups fields by section, producing a Card per Amendable sub-model.
GENERATE_EDIT_FORM() := BEGIN
    result := [];
    IF _edit_fields = null OR LENGTH(_edit_fields) = 0 THEN
        RETURN result;

    current_section := '';

    FOR i := 0 TO LENGTH(_edit_fields) - 1 DO BEGIN
        fld := _edit_fields[i];

        -- Section header when section changes (each Amendable gets its own Card-like header)
        IF fld.SECTION <> current_section AND fld.SECTION <> '' THEN BEGIN
            current_section := fld.SECTION;
            -- Add spacing + section header
            result := result + [
                {"type": "SizedBox", "props": {"height": 24}},
                {"type": "Text", "props": {
                    "data": current_section,
                    "style": {"fontSize": 16, "fontWeight": "bold", "color": "0xFF1976D2"}
                }},
                {"type": "SizedBox", "props": {"height": 8}}
            ];
        END;

        -- Field label
        result := result + [
            {"type": "Text", "props": {
                "data": fld.LABEL,
                "style": {"fontWeight": "bold", "fontSize": 14}
            }},
            {"type": "SizedBox", "props": {"height": 4}}
        ];

        -- Widget depends on field_type
        IF fld.FIELD_TYPE = 'enum' THEN BEGIN
            -- Dropdown for enum fields
            result := result + [
                {"type": "DropdownButton", "props": {
                    "items": fld.OPTIONS,
                    "value": fld.VALUE,
                    "hint": "Select " + fld.LABEL,
                    "onChanged": "shql: _edit_fields[" + STRING(i) + "].VALUE := value"
                }}
            ];
        END ELSE BEGIN
            -- TextField for string/number fields
            result := result + [
                {"type": "TextField", "props": {
                    "initialValue": fld.VALUE,
                    "decoration": {"border": "outline"},
                    "onChanged": "shql: _edit_fields[" + STRING(i) + "].VALUE := value"
                }}
            ];
        END;

        result := result + [{"type": "SizedBox", "props": {"height": 16}}];
    END;

    RETURN result;
END;

-- ============================================
-- Weather (pure SHQL™ — no Dart service needed)
-- ============================================
_weather_temp := null;
_weather_description := '';
_weather_icon := 'cloud';
_weather_wind := 0;

-- WMO Weather interpretation codes → human description
-- (named __WMO_* to avoid colliding with _weather_* variables — SHQL™ is case-insensitive)
__WMO_DESCRIPTION(code) := BEGIN
    IF code = 0 THEN RETURN 'Clear sky';
    IF code <= 3 THEN RETURN 'Partly cloudy';
    IF code <= 48 THEN RETURN 'Foggy';
    IF code <= 57 THEN RETURN 'Drizzle';
    IF code <= 67 THEN RETURN 'Rain';
    IF code <= 77 THEN RETURN 'Snow';
    IF code <= 82 THEN RETURN 'Rain showers';
    IF code <= 86 THEN RETURN 'Snow showers';
    IF code >= 95 THEN RETURN 'Thunderstorm';
    RETURN 'Cloudy';
END;

-- WMO code → Material icon name
__WMO_ICON(code) := BEGIN
    IF code = 0 THEN RETURN 'wb_sunny';
    IF code <= 3 THEN RETURN 'cloud';
    IF code <= 48 THEN RETURN 'foggy';
    IF code <= 67 THEN RETURN 'water_drop';
    IF code <= 77 THEN RETURN 'ac_unit';
    IF code <= 86 THEN RETURN 'ac_unit';
    IF code >= 95 THEN RETURN 'flash_on';
    RETURN 'cloud';
END;

-- Fetch weather from Open-Meteo (free, no API key) using SHQL™ FETCH()
REFRESH_WEATHER() := BEGIN
    __url := 'https://api.open-meteo.com/v1/forecast?latitude=' + STRING(_user_latitude) + '&longitude=' + STRING(_user_longitude) + '&current_weather=true';
    __data := FETCH(__url);
    IF __data <> null AND __data["current_weather"] <> null THEN BEGIN
        __current := __data["current_weather"];
        __code := __current["weathercode"];
        -- Use SET() not := so Observer widgets rebuild
        SET('_weather_temp', __current["temperature"]);
        SET('_weather_wind', __current["windspeed"]);
        SET('_weather_description', __WMO_DESCRIPTION(__code));
        SET('_weather_icon', __WMO_ICON(__code));
    END;
END;


-- ============================================
-- Location & Battle Map
-- ============================================
_location_description := '';
_user_latitude := 56.28;
_user_longitude := 13.28;
_battle_locations := [];

-- Generate the complete battle map widget tree (FlutterMap + markers).
GENERATE_BATTLE_MAP() := BEGIN
    __markers := [];
    __hero_list := MAP_VALUES(_heroes);
    FOR i := 0 TO LENGTH(__hero_list) - 1 DO BEGIN
        hero := __hero_list[i];
        name := NVL(hero, h => h.name, "Unknown");
        alignment := BIOGRAPHY(hero, b => b.alignment, NEUTRAL);
        -- Spread heroes around user location using a simple deterministic offset
        -- based on the hero index to avoid all markers stacking
        angle := i * 2.39996;  --- golden angle in radians
        radius := 0.05 + (i % 7) * 0.02;
        lat := _user_latitude + radius * COS(angle);
        lon := _user_longitude + radius * SIN(angle);
        __is_villain := alignment > GOOD;
        __color := IF __is_villain THEN '0xFFF44336' ELSE '0xFF2196F3';

        -- Marker child: Tooltip > Container(circle, shadow) > Icon
        __marker_child := {"type": "Tooltip", "props": {
            "message": name,
            "child": {"type": "Container", "props": {
                "decoration": {
                    "color": __color,
                    "shape": "circle",
                    "border": {"color": "0xFFFFFFFF", "width": 2},
                    "boxShadow": [{"blurRadius": 4, "color": "0x42000000"}]
                },
                "child": {"type": "Icon", "props": {"icon": IF __is_villain THEN "dangerous" ELSE "shield", "color": "0xFFFFFFFF", "size": 20}}
            }}
        }};

        __markers := __markers + [{"lat": lat, "lon": lon, "child": __marker_child}];
    END;

    RETURN {"type": "FlutterMap", "props": {
        "latitude": _user_latitude,
        "longitude": _user_longitude,
        "zoom": 10,
        "children": [
            {"type": "TileLayer", "props": {}},
            {"type": "MarkerLayer", "props": {"markers": __markers}}
        ]
    }};
END;

-- ============================================
-- War Status
-- ============================================
_war_messages := [
    "The invasion has been pushed back 47%",
    "Heroes are making progress in sector 7",
    "Villains have joined forces against the common enemy",
    "Defense grid holding steady",
    "New recruits arriving daily",
    "Morale is high among the defenders"
];

GET_WAR_STATUS() := BEGIN
    -- Return a "random" message based on current second
    index := INT(_total_heroes) % LENGTH(_war_messages);
    RETURN _war_messages[index];
END;

-- Fetch weather on startup (must be after _user_latitude/_user_longitude are defined)
REFRESH_WEATHER();
