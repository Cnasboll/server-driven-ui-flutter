-- ============================================
-- Firestore Preferences Sync
-- ============================================
-- Syncs selected preferences to Firestore via REST API (per-user).
-- Auth.FIREBASE_API_KEY and Auth.FIREBASE_PROJECT_ID are defined in auth.shql.
-- _auth_uid is persisted by auth.shql on sign-in.

Cloud := OBJECT{
    auth_uid: LOAD_STATE('_auth_uid', ''),

    SET_AUTH_UID: (uid) => BEGIN
        auth_uid := uid;
        PUBLISH('Cloud.auth_uid');
    END,

    SYNCED_KEYS: ['is_dark_mode', 'api_key', 'api_host',
        'onboarding_completed', 'analytics_enabled', 'crashlytics_enabled',
        'location_enabled', 'filters'],

    __DOC_URL: () => BEGIN
        RETURN 'https://firestore.googleapis.com/v1/projects/' + Auth.FIREBASE_PROJECT_ID
            + '/databases/(default)/documents/preferences/' + auth_uid;
    END,

    -- Convert a Dart value to Firestore REST value format.
    __TO_VALUE: (val) => BEGIN
        __fv := {};
        IF val = TRUE OR val = FALSE THEN BEGIN
            __fv["booleanValue"] := val;
            RETURN __fv;
        END;
        __fv["stringValue"] := STRING(val);
        RETURN __fv;
    END,

    -- Convert a Firestore REST value back to a Dart value
    __FROM_VALUE: (val) => BEGIN
        IF val["booleanValue"] <> null THEN RETURN val["booleanValue"];
        IF val["integerValue"] <> null THEN RETURN NUMBER(val["integerValue"]);
        IF val["doubleValue"] <> null THEN RETURN val["doubleValue"];
        IF val["stringValue"] <> null THEN RETURN val["stringValue"];
        RETURN null;
    END,

    -- Get a valid auth token, refreshing if expired.
    __TOKEN: () => BEGIN
        __token := LOAD_STATE('_auth_id_token', '');
        IF __token = '' THEN
            __token := Auth.FIREBASE_REFRESH_TOKEN();
        RETURN __token;
    END,

    -- Save a preference to Firestore (fire-and-forget via PATCH_AUTH).
    -- Auto-refreshes the token on 401.
    SAVE: (key, value) => BEGIN
        IF auth_uid = '' THEN RETURN null;
        IF NOT (key IN SYNCED_KEYS) THEN RETURN null;
        __token := __TOKEN();
        IF __token = '' THEN RETURN null;
        __fields := {};
        __fields[key] := __TO_VALUE(value);
        __url := __DOC_URL() + '?updateMask.fieldPaths=' + key;
        __patch_body := {};
        __patch_body["fields"] := __fields;
        __result := PATCH_AUTH(__url, __patch_body, __token);
        IF __result["status"] = 401 THEN BEGIN
            __token := Auth.FIREBASE_REFRESH_TOKEN();
            IF __token <> '' THEN
                PATCH_AUTH(__url, __patch_body, __token);
        END;
    END,

    -- Load all synced preferences from Firestore.
    -- Auto-refreshes the token if the first attempt fails.
    LOAD_ALL: () => BEGIN
        IF auth_uid = '' THEN RETURN {};
        __token := __TOKEN();
        IF __token = '' THEN RETURN {};
        __response := FETCH_AUTH(__DOC_URL(), __token);
        -- If null, token may be expired â€” try refresh once
        IF __response = null THEN BEGIN
            __token := Auth.FIREBASE_REFRESH_TOKEN();
            IF __token = '' THEN RETURN {};
            __response := FETCH_AUTH(__DOC_URL(), __token);
            IF __response = null THEN RETURN {};
        END;
        __fields := __response["fields"];
        IF __fields = null THEN RETURN {};
        __result := {};
        FOR __i := 0 TO LENGTH(SYNCED_KEYS) - 1 DO BEGIN
            __key := SYNCED_KEYS[__i];
            __fval := __fields[__key];
            IF __fval <> null THEN
                __result[__key] := __FROM_VALUE(__fval);
        END;
        RETURN __result;
    END,

    -- Wrapper: save locally + sync to Firestore
    SAVE_PREF: (key, value) => BEGIN
        SAVE_STATE(key, value);
        SAVE(key, value);
    END
};

